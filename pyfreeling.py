# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pyfreeling
else:
    import _pyfreeling

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyfreeling.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _pyfreeling.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _pyfreeling.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _pyfreeling.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _pyfreeling.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _pyfreeling.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _pyfreeling.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _pyfreeling.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _pyfreeling.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _pyfreeling.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _pyfreeling.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _pyfreeling.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _pyfreeling.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _pyfreeling.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _pyfreeling.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _pyfreeling.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pyfreeling:
_pyfreeling.SwigPyIterator_swigregister(SwigPyIterator)

class VectorWord(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorWord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorWord___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorWord___bool__(self)

    def __len__(self) -> "std::vector< freeling::word >::size_type":
        return _pyfreeling.VectorWord___len__(self)

    def __getslice__(self, i: "std::vector< freeling::word >::difference_type", j: "std::vector< freeling::word >::difference_type") -> "std::vector< freeling::word,std::allocator< freeling::word > > *":
        return _pyfreeling.VectorWord___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorWord___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::word >::difference_type", j: "std::vector< freeling::word >::difference_type") -> "void":
        return _pyfreeling.VectorWord___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorWord___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::word >::value_type const &":
        return _pyfreeling.VectorWord___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorWord___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::word >::value_type":
        return _pyfreeling.VectorWord_pop(self)

    def append(self, x: "word") -> "void":
        return _pyfreeling.VectorWord_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorWord_empty(self)

    def size(self) -> "std::vector< freeling::word >::size_type":
        return _pyfreeling.VectorWord_size(self)

    def swap(self, v: "VectorWord") -> "void":
        return _pyfreeling.VectorWord_swap(self, v)

    def begin(self) -> "std::vector< freeling::word >::iterator":
        return _pyfreeling.VectorWord_begin(self)

    def end(self) -> "std::vector< freeling::word >::iterator":
        return _pyfreeling.VectorWord_end(self)

    def rbegin(self) -> "std::vector< freeling::word >::reverse_iterator":
        return _pyfreeling.VectorWord_rbegin(self)

    def rend(self) -> "std::vector< freeling::word >::reverse_iterator":
        return _pyfreeling.VectorWord_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorWord_clear(self)

    def get_allocator(self) -> "std::vector< freeling::word >::allocator_type":
        return _pyfreeling.VectorWord_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorWord_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::word >::iterator":
        return _pyfreeling.VectorWord_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorWord_swiginit(self, _pyfreeling.new_VectorWord(*args))

    def push_back(self, x: "word") -> "void":
        return _pyfreeling.VectorWord_push_back(self, x)

    def front(self) -> "std::vector< freeling::word >::value_type const &":
        return _pyfreeling.VectorWord_front(self)

    def back(self) -> "std::vector< freeling::word >::value_type const &":
        return _pyfreeling.VectorWord_back(self)

    def assign(self, n: "std::vector< freeling::word >::size_type", x: "word") -> "void":
        return _pyfreeling.VectorWord_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorWord_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorWord_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::word >::size_type") -> "void":
        return _pyfreeling.VectorWord_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::word >::size_type":
        return _pyfreeling.VectorWord_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorWord

# Register VectorWord in _pyfreeling:
_pyfreeling.VectorWord_swigregister(VectorWord)

class ListWord(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListWord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListWord___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListWord___bool__(self)

    def __len__(self) -> "std::list< freeling::word >::size_type":
        return _pyfreeling.ListWord___len__(self)

    def __getslice__(self, i: "std::list< freeling::word >::difference_type", j: "std::list< freeling::word >::difference_type") -> "std::list< freeling::word,std::allocator< freeling::word > > *":
        return _pyfreeling.ListWord___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListWord___setslice__(self, *args)

    def __delslice__(self, i: "std::list< freeling::word >::difference_type", j: "std::list< freeling::word >::difference_type") -> "void":
        return _pyfreeling.ListWord___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListWord___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::word >::value_type const &":
        return _pyfreeling.ListWord___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListWord___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::word >::value_type":
        return _pyfreeling.ListWord_pop(self)

    def append(self, x: "word") -> "void":
        return _pyfreeling.ListWord_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListWord_empty(self)

    def size(self) -> "std::list< freeling::word >::size_type":
        return _pyfreeling.ListWord_size(self)

    def swap(self, v: "ListWord") -> "void":
        return _pyfreeling.ListWord_swap(self, v)

    def begin(self) -> "std::list< freeling::word >::iterator":
        return _pyfreeling.ListWord_begin(self)

    def end(self) -> "std::list< freeling::word >::iterator":
        return _pyfreeling.ListWord_end(self)

    def rbegin(self) -> "std::list< freeling::word >::reverse_iterator":
        return _pyfreeling.ListWord_rbegin(self)

    def rend(self) -> "std::list< freeling::word >::reverse_iterator":
        return _pyfreeling.ListWord_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListWord_clear(self)

    def get_allocator(self) -> "std::list< freeling::word >::allocator_type":
        return _pyfreeling.ListWord_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListWord_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::word >::iterator":
        return _pyfreeling.ListWord_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListWord_swiginit(self, _pyfreeling.new_ListWord(*args))

    def push_back(self, x: "word") -> "void":
        return _pyfreeling.ListWord_push_back(self, x)

    def front(self) -> "std::list< freeling::word >::value_type const &":
        return _pyfreeling.ListWord_front(self)

    def back(self) -> "std::list< freeling::word >::value_type const &":
        return _pyfreeling.ListWord_back(self)

    def assign(self, n: "std::list< freeling::word >::size_type", x: "word") -> "void":
        return _pyfreeling.ListWord_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListWord_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListWord_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListWord_pop_front(self)

    def push_front(self, x: "word") -> "void":
        return _pyfreeling.ListWord_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListWord_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListWord

# Register ListWord in _pyfreeling:
_pyfreeling.ListWord_swigregister(ListWord)

class ListAnalysis(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListAnalysis_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListAnalysis___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListAnalysis___bool__(self)

    def __len__(self) -> "std::list< freeling::analysis >::size_type":
        return _pyfreeling.ListAnalysis___len__(self)

    def __getslice__(self, i: "std::list< freeling::analysis >::difference_type", j: "std::list< freeling::analysis >::difference_type") -> "std::list< freeling::analysis,std::allocator< freeling::analysis > > *":
        return _pyfreeling.ListAnalysis___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListAnalysis___setslice__(self, *args)

    def __delslice__(self, i: "std::list< freeling::analysis >::difference_type", j: "std::list< freeling::analysis >::difference_type") -> "void":
        return _pyfreeling.ListAnalysis___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListAnalysis___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::analysis >::value_type const &":
        return _pyfreeling.ListAnalysis___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListAnalysis___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::analysis >::value_type":
        return _pyfreeling.ListAnalysis_pop(self)

    def append(self, x: "analysis") -> "void":
        return _pyfreeling.ListAnalysis_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListAnalysis_empty(self)

    def size(self) -> "std::list< freeling::analysis >::size_type":
        return _pyfreeling.ListAnalysis_size(self)

    def swap(self, v: "ListAnalysis") -> "void":
        return _pyfreeling.ListAnalysis_swap(self, v)

    def begin(self) -> "std::list< freeling::analysis >::iterator":
        return _pyfreeling.ListAnalysis_begin(self)

    def end(self) -> "std::list< freeling::analysis >::iterator":
        return _pyfreeling.ListAnalysis_end(self)

    def rbegin(self) -> "std::list< freeling::analysis >::reverse_iterator":
        return _pyfreeling.ListAnalysis_rbegin(self)

    def rend(self) -> "std::list< freeling::analysis >::reverse_iterator":
        return _pyfreeling.ListAnalysis_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListAnalysis_clear(self)

    def get_allocator(self) -> "std::list< freeling::analysis >::allocator_type":
        return _pyfreeling.ListAnalysis_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListAnalysis_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::analysis >::iterator":
        return _pyfreeling.ListAnalysis_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListAnalysis_swiginit(self, _pyfreeling.new_ListAnalysis(*args))

    def push_back(self, x: "analysis") -> "void":
        return _pyfreeling.ListAnalysis_push_back(self, x)

    def front(self) -> "std::list< freeling::analysis >::value_type const &":
        return _pyfreeling.ListAnalysis_front(self)

    def back(self) -> "std::list< freeling::analysis >::value_type const &":
        return _pyfreeling.ListAnalysis_back(self)

    def assign(self, n: "std::list< freeling::analysis >::size_type", x: "analysis") -> "void":
        return _pyfreeling.ListAnalysis_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListAnalysis_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListAnalysis_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListAnalysis_pop_front(self)

    def push_front(self, x: "analysis") -> "void":
        return _pyfreeling.ListAnalysis_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListAnalysis_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListAnalysis

# Register ListAnalysis in _pyfreeling:
_pyfreeling.ListAnalysis_swigregister(ListAnalysis)

class ListAlternative(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListAlternative_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListAlternative___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListAlternative___bool__(self)

    def __len__(self) -> "std::list< freeling::alternative >::size_type":
        return _pyfreeling.ListAlternative___len__(self)

    def __getslice__(self, i: "std::list< freeling::alternative >::difference_type", j: "std::list< freeling::alternative >::difference_type") -> "std::list< freeling::alternative,std::allocator< freeling::alternative > > *":
        return _pyfreeling.ListAlternative___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListAlternative___setslice__(self, *args)

    def __delslice__(self, i: "std::list< freeling::alternative >::difference_type", j: "std::list< freeling::alternative >::difference_type") -> "void":
        return _pyfreeling.ListAlternative___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListAlternative___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::alternative >::value_type const &":
        return _pyfreeling.ListAlternative___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListAlternative___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::alternative >::value_type":
        return _pyfreeling.ListAlternative_pop(self)

    def append(self, x: "alternative") -> "void":
        return _pyfreeling.ListAlternative_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListAlternative_empty(self)

    def size(self) -> "std::list< freeling::alternative >::size_type":
        return _pyfreeling.ListAlternative_size(self)

    def swap(self, v: "ListAlternative") -> "void":
        return _pyfreeling.ListAlternative_swap(self, v)

    def begin(self) -> "std::list< freeling::alternative >::iterator":
        return _pyfreeling.ListAlternative_begin(self)

    def end(self) -> "std::list< freeling::alternative >::iterator":
        return _pyfreeling.ListAlternative_end(self)

    def rbegin(self) -> "std::list< freeling::alternative >::reverse_iterator":
        return _pyfreeling.ListAlternative_rbegin(self)

    def rend(self) -> "std::list< freeling::alternative >::reverse_iterator":
        return _pyfreeling.ListAlternative_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListAlternative_clear(self)

    def get_allocator(self) -> "std::list< freeling::alternative >::allocator_type":
        return _pyfreeling.ListAlternative_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListAlternative_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::alternative >::iterator":
        return _pyfreeling.ListAlternative_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListAlternative_swiginit(self, _pyfreeling.new_ListAlternative(*args))

    def push_back(self, x: "alternative") -> "void":
        return _pyfreeling.ListAlternative_push_back(self, x)

    def front(self) -> "std::list< freeling::alternative >::value_type const &":
        return _pyfreeling.ListAlternative_front(self)

    def back(self) -> "std::list< freeling::alternative >::value_type const &":
        return _pyfreeling.ListAlternative_back(self)

    def assign(self, n: "std::list< freeling::alternative >::size_type", x: "alternative") -> "void":
        return _pyfreeling.ListAlternative_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListAlternative_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListAlternative_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListAlternative_pop_front(self)

    def push_front(self, x: "alternative") -> "void":
        return _pyfreeling.ListAlternative_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListAlternative_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListAlternative

# Register ListAlternative in _pyfreeling:
_pyfreeling.ListAlternative_swigregister(ListAlternative)

class ListSentence(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListSentence_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListSentence___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListSentence___bool__(self)

    def __len__(self) -> "std::list< freeling::sentence >::size_type":
        return _pyfreeling.ListSentence___len__(self)

    def __getslice__(self, i: "std::list< freeling::sentence >::difference_type", j: "std::list< freeling::sentence >::difference_type") -> "std::list< freeling::sentence,std::allocator< freeling::sentence > > *":
        return _pyfreeling.ListSentence___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListSentence___setslice__(self, *args)

    def __delslice__(self, i: "std::list< freeling::sentence >::difference_type", j: "std::list< freeling::sentence >::difference_type") -> "void":
        return _pyfreeling.ListSentence___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListSentence___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::sentence >::value_type const &":
        return _pyfreeling.ListSentence___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListSentence___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::sentence >::value_type":
        return _pyfreeling.ListSentence_pop(self)

    def append(self, x: "sentence") -> "void":
        return _pyfreeling.ListSentence_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListSentence_empty(self)

    def size(self) -> "std::list< freeling::sentence >::size_type":
        return _pyfreeling.ListSentence_size(self)

    def swap(self, v: "ListSentence") -> "void":
        return _pyfreeling.ListSentence_swap(self, v)

    def begin(self) -> "std::list< freeling::sentence >::iterator":
        return _pyfreeling.ListSentence_begin(self)

    def end(self) -> "std::list< freeling::sentence >::iterator":
        return _pyfreeling.ListSentence_end(self)

    def rbegin(self) -> "std::list< freeling::sentence >::reverse_iterator":
        return _pyfreeling.ListSentence_rbegin(self)

    def rend(self) -> "std::list< freeling::sentence >::reverse_iterator":
        return _pyfreeling.ListSentence_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListSentence_clear(self)

    def get_allocator(self) -> "std::list< freeling::sentence >::allocator_type":
        return _pyfreeling.ListSentence_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListSentence_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::sentence >::iterator":
        return _pyfreeling.ListSentence_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListSentence_swiginit(self, _pyfreeling.new_ListSentence(*args))

    def push_back(self, x: "sentence") -> "void":
        return _pyfreeling.ListSentence_push_back(self, x)

    def front(self) -> "std::list< freeling::sentence >::value_type const &":
        return _pyfreeling.ListSentence_front(self)

    def back(self) -> "std::list< freeling::sentence >::value_type const &":
        return _pyfreeling.ListSentence_back(self)

    def assign(self, n: "std::list< freeling::sentence >::size_type", x: "sentence") -> "void":
        return _pyfreeling.ListSentence_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListSentence_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListSentence_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListSentence_pop_front(self)

    def push_front(self, x: "sentence") -> "void":
        return _pyfreeling.ListSentence_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListSentence_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListSentence

# Register ListSentence in _pyfreeling:
_pyfreeling.ListSentence_swigregister(ListSentence)

class ListParagraph(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListParagraph_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListParagraph___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListParagraph___bool__(self)

    def __len__(self) -> "std::list< freeling::paragraph >::size_type":
        return _pyfreeling.ListParagraph___len__(self)

    def __getslice__(self, i: "std::list< freeling::paragraph >::difference_type", j: "std::list< freeling::paragraph >::difference_type") -> "std::list< freeling::paragraph,std::allocator< freeling::paragraph > > *":
        return _pyfreeling.ListParagraph___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListParagraph___setslice__(self, *args)

    def __delslice__(self, i: "std::list< freeling::paragraph >::difference_type", j: "std::list< freeling::paragraph >::difference_type") -> "void":
        return _pyfreeling.ListParagraph___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListParagraph___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::paragraph >::value_type const &":
        return _pyfreeling.ListParagraph___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListParagraph___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::paragraph >::value_type":
        return _pyfreeling.ListParagraph_pop(self)

    def append(self, x: "paragraph") -> "void":
        return _pyfreeling.ListParagraph_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListParagraph_empty(self)

    def size(self) -> "std::list< freeling::paragraph >::size_type":
        return _pyfreeling.ListParagraph_size(self)

    def swap(self, v: "ListParagraph") -> "void":
        return _pyfreeling.ListParagraph_swap(self, v)

    def begin(self) -> "std::list< freeling::paragraph >::iterator":
        return _pyfreeling.ListParagraph_begin(self)

    def end(self) -> "std::list< freeling::paragraph >::iterator":
        return _pyfreeling.ListParagraph_end(self)

    def rbegin(self) -> "std::list< freeling::paragraph >::reverse_iterator":
        return _pyfreeling.ListParagraph_rbegin(self)

    def rend(self) -> "std::list< freeling::paragraph >::reverse_iterator":
        return _pyfreeling.ListParagraph_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListParagraph_clear(self)

    def get_allocator(self) -> "std::list< freeling::paragraph >::allocator_type":
        return _pyfreeling.ListParagraph_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListParagraph_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::paragraph >::iterator":
        return _pyfreeling.ListParagraph_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListParagraph_swiginit(self, _pyfreeling.new_ListParagraph(*args))

    def push_back(self, x: "paragraph") -> "void":
        return _pyfreeling.ListParagraph_push_back(self, x)

    def front(self) -> "std::list< freeling::paragraph >::value_type const &":
        return _pyfreeling.ListParagraph_front(self)

    def back(self) -> "std::list< freeling::paragraph >::value_type const &":
        return _pyfreeling.ListParagraph_back(self)

    def assign(self, n: "std::list< freeling::paragraph >::size_type", x: "paragraph") -> "void":
        return _pyfreeling.ListParagraph_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListParagraph_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListParagraph_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListParagraph_pop_front(self)

    def push_front(self, x: "paragraph") -> "void":
        return _pyfreeling.ListParagraph_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListParagraph_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListParagraph

# Register ListParagraph in _pyfreeling:
_pyfreeling.ListParagraph_swigregister(ListParagraph)

class VectorArgument(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorArgument_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorArgument___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorArgument___bool__(self)

    def __len__(self) -> "std::vector< freeling::argument >::size_type":
        return _pyfreeling.VectorArgument___len__(self)

    def __getslice__(self, i: "std::vector< freeling::argument >::difference_type", j: "std::vector< freeling::argument >::difference_type") -> "std::vector< freeling::argument,std::allocator< freeling::argument > > *":
        return _pyfreeling.VectorArgument___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorArgument___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::argument >::difference_type", j: "std::vector< freeling::argument >::difference_type") -> "void":
        return _pyfreeling.VectorArgument___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorArgument___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::argument >::value_type const &":
        return _pyfreeling.VectorArgument___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorArgument___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::argument >::value_type":
        return _pyfreeling.VectorArgument_pop(self)

    def append(self, x: "argument") -> "void":
        return _pyfreeling.VectorArgument_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorArgument_empty(self)

    def size(self) -> "std::vector< freeling::argument >::size_type":
        return _pyfreeling.VectorArgument_size(self)

    def swap(self, v: "VectorArgument") -> "void":
        return _pyfreeling.VectorArgument_swap(self, v)

    def begin(self) -> "std::vector< freeling::argument >::iterator":
        return _pyfreeling.VectorArgument_begin(self)

    def end(self) -> "std::vector< freeling::argument >::iterator":
        return _pyfreeling.VectorArgument_end(self)

    def rbegin(self) -> "std::vector< freeling::argument >::reverse_iterator":
        return _pyfreeling.VectorArgument_rbegin(self)

    def rend(self) -> "std::vector< freeling::argument >::reverse_iterator":
        return _pyfreeling.VectorArgument_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorArgument_clear(self)

    def get_allocator(self) -> "std::vector< freeling::argument >::allocator_type":
        return _pyfreeling.VectorArgument_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorArgument_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::argument >::iterator":
        return _pyfreeling.VectorArgument_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorArgument_swiginit(self, _pyfreeling.new_VectorArgument(*args))

    def push_back(self, x: "argument") -> "void":
        return _pyfreeling.VectorArgument_push_back(self, x)

    def front(self) -> "std::vector< freeling::argument >::value_type const &":
        return _pyfreeling.VectorArgument_front(self)

    def back(self) -> "std::vector< freeling::argument >::value_type const &":
        return _pyfreeling.VectorArgument_back(self)

    def assign(self, n: "std::vector< freeling::argument >::size_type", x: "argument") -> "void":
        return _pyfreeling.VectorArgument_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorArgument_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorArgument_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::argument >::size_type") -> "void":
        return _pyfreeling.VectorArgument_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::argument >::size_type":
        return _pyfreeling.VectorArgument_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorArgument

# Register VectorArgument in _pyfreeling:
_pyfreeling.VectorArgument_swigregister(VectorArgument)

class VectorPredicate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorPredicate_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorPredicate___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorPredicate___bool__(self)

    def __len__(self) -> "std::vector< freeling::predicate >::size_type":
        return _pyfreeling.VectorPredicate___len__(self)

    def __getslice__(self, i: "std::vector< freeling::predicate >::difference_type", j: "std::vector< freeling::predicate >::difference_type") -> "std::vector< freeling::predicate,std::allocator< freeling::predicate > > *":
        return _pyfreeling.VectorPredicate___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorPredicate___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::predicate >::difference_type", j: "std::vector< freeling::predicate >::difference_type") -> "void":
        return _pyfreeling.VectorPredicate___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorPredicate___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::predicate >::value_type const &":
        return _pyfreeling.VectorPredicate___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorPredicate___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::predicate >::value_type":
        return _pyfreeling.VectorPredicate_pop(self)

    def append(self, x: "predicate") -> "void":
        return _pyfreeling.VectorPredicate_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorPredicate_empty(self)

    def size(self) -> "std::vector< freeling::predicate >::size_type":
        return _pyfreeling.VectorPredicate_size(self)

    def swap(self, v: "VectorPredicate") -> "void":
        return _pyfreeling.VectorPredicate_swap(self, v)

    def begin(self) -> "std::vector< freeling::predicate >::iterator":
        return _pyfreeling.VectorPredicate_begin(self)

    def end(self) -> "std::vector< freeling::predicate >::iterator":
        return _pyfreeling.VectorPredicate_end(self)

    def rbegin(self) -> "std::vector< freeling::predicate >::reverse_iterator":
        return _pyfreeling.VectorPredicate_rbegin(self)

    def rend(self) -> "std::vector< freeling::predicate >::reverse_iterator":
        return _pyfreeling.VectorPredicate_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorPredicate_clear(self)

    def get_allocator(self) -> "std::vector< freeling::predicate >::allocator_type":
        return _pyfreeling.VectorPredicate_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorPredicate_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::predicate >::iterator":
        return _pyfreeling.VectorPredicate_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorPredicate_swiginit(self, _pyfreeling.new_VectorPredicate(*args))

    def push_back(self, x: "predicate") -> "void":
        return _pyfreeling.VectorPredicate_push_back(self, x)

    def front(self) -> "std::vector< freeling::predicate >::value_type const &":
        return _pyfreeling.VectorPredicate_front(self)

    def back(self) -> "std::vector< freeling::predicate >::value_type const &":
        return _pyfreeling.VectorPredicate_back(self)

    def assign(self, n: "std::vector< freeling::predicate >::size_type", x: "predicate") -> "void":
        return _pyfreeling.VectorPredicate_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorPredicate_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorPredicate_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::predicate >::size_type") -> "void":
        return _pyfreeling.VectorPredicate_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::predicate >::size_type":
        return _pyfreeling.VectorPredicate_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorPredicate

# Register VectorPredicate in _pyfreeling:
_pyfreeling.VectorPredicate_swigregister(VectorPredicate)

class VectorSGMention(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorSGMention_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorSGMention___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorSGMention___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_mention >::size_type":
        return _pyfreeling.VectorSGMention___len__(self)

    def __getslice__(self, i: "std::vector< freeling::semgraph::SG_mention >::difference_type", j: "std::vector< freeling::semgraph::SG_mention >::difference_type") -> "std::vector< freeling::semgraph::SG_mention,std::allocator< freeling::semgraph::SG_mention > > *":
        return _pyfreeling.VectorSGMention___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorSGMention___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::semgraph::SG_mention >::difference_type", j: "std::vector< freeling::semgraph::SG_mention >::difference_type") -> "void":
        return _pyfreeling.VectorSGMention___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGMention___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_mention >::value_type const &":
        return _pyfreeling.VectorSGMention___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGMention___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_mention >::value_type":
        return _pyfreeling.VectorSGMention_pop(self)

    def append(self, x: "SG_mention") -> "void":
        return _pyfreeling.VectorSGMention_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorSGMention_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_mention >::size_type":
        return _pyfreeling.VectorSGMention_size(self)

    def swap(self, v: "VectorSGMention") -> "void":
        return _pyfreeling.VectorSGMention_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_mention >::iterator":
        return _pyfreeling.VectorSGMention_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_mention >::iterator":
        return _pyfreeling.VectorSGMention_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_mention >::reverse_iterator":
        return _pyfreeling.VectorSGMention_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_mention >::reverse_iterator":
        return _pyfreeling.VectorSGMention_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorSGMention_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_mention >::allocator_type":
        return _pyfreeling.VectorSGMention_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorSGMention_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_mention >::iterator":
        return _pyfreeling.VectorSGMention_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorSGMention_swiginit(self, _pyfreeling.new_VectorSGMention(*args))

    def push_back(self, x: "SG_mention") -> "void":
        return _pyfreeling.VectorSGMention_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_mention >::value_type const &":
        return _pyfreeling.VectorSGMention_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_mention >::value_type const &":
        return _pyfreeling.VectorSGMention_back(self)

    def assign(self, n: "std::vector< freeling::semgraph::SG_mention >::size_type", x: "SG_mention") -> "void":
        return _pyfreeling.VectorSGMention_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorSGMention_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorSGMention_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::semgraph::SG_mention >::size_type") -> "void":
        return _pyfreeling.VectorSGMention_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_mention >::size_type":
        return _pyfreeling.VectorSGMention_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorSGMention

# Register VectorSGMention in _pyfreeling:
_pyfreeling.VectorSGMention_swigregister(VectorSGMention)

class VectorSGArgument(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorSGArgument_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorSGArgument___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorSGArgument___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_argument >::size_type":
        return _pyfreeling.VectorSGArgument___len__(self)

    def __getslice__(self, i: "std::vector< freeling::semgraph::SG_argument >::difference_type", j: "std::vector< freeling::semgraph::SG_argument >::difference_type") -> "std::vector< freeling::semgraph::SG_argument,std::allocator< freeling::semgraph::SG_argument > > *":
        return _pyfreeling.VectorSGArgument___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorSGArgument___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::semgraph::SG_argument >::difference_type", j: "std::vector< freeling::semgraph::SG_argument >::difference_type") -> "void":
        return _pyfreeling.VectorSGArgument___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGArgument___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_argument >::value_type const &":
        return _pyfreeling.VectorSGArgument___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGArgument___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_argument >::value_type":
        return _pyfreeling.VectorSGArgument_pop(self)

    def append(self, x: "SG_argument") -> "void":
        return _pyfreeling.VectorSGArgument_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorSGArgument_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_argument >::size_type":
        return _pyfreeling.VectorSGArgument_size(self)

    def swap(self, v: "VectorSGArgument") -> "void":
        return _pyfreeling.VectorSGArgument_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_argument >::iterator":
        return _pyfreeling.VectorSGArgument_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_argument >::iterator":
        return _pyfreeling.VectorSGArgument_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_argument >::reverse_iterator":
        return _pyfreeling.VectorSGArgument_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_argument >::reverse_iterator":
        return _pyfreeling.VectorSGArgument_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorSGArgument_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_argument >::allocator_type":
        return _pyfreeling.VectorSGArgument_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorSGArgument_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_argument >::iterator":
        return _pyfreeling.VectorSGArgument_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorSGArgument_swiginit(self, _pyfreeling.new_VectorSGArgument(*args))

    def push_back(self, x: "SG_argument") -> "void":
        return _pyfreeling.VectorSGArgument_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_argument >::value_type const &":
        return _pyfreeling.VectorSGArgument_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_argument >::value_type const &":
        return _pyfreeling.VectorSGArgument_back(self)

    def assign(self, n: "std::vector< freeling::semgraph::SG_argument >::size_type", x: "SG_argument") -> "void":
        return _pyfreeling.VectorSGArgument_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorSGArgument_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorSGArgument_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::semgraph::SG_argument >::size_type") -> "void":
        return _pyfreeling.VectorSGArgument_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_argument >::size_type":
        return _pyfreeling.VectorSGArgument_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorSGArgument

# Register VectorSGArgument in _pyfreeling:
_pyfreeling.VectorSGArgument_swigregister(VectorSGArgument)

class VectorSGEntity(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorSGEntity_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorSGEntity___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorSGEntity___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_entity >::size_type":
        return _pyfreeling.VectorSGEntity___len__(self)

    def __getslice__(self, i: "std::vector< freeling::semgraph::SG_entity >::difference_type", j: "std::vector< freeling::semgraph::SG_entity >::difference_type") -> "std::vector< freeling::semgraph::SG_entity,std::allocator< freeling::semgraph::SG_entity > > *":
        return _pyfreeling.VectorSGEntity___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorSGEntity___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::semgraph::SG_entity >::difference_type", j: "std::vector< freeling::semgraph::SG_entity >::difference_type") -> "void":
        return _pyfreeling.VectorSGEntity___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGEntity___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_entity >::value_type const &":
        return _pyfreeling.VectorSGEntity___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGEntity___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_entity >::value_type":
        return _pyfreeling.VectorSGEntity_pop(self)

    def append(self, x: "SG_entity") -> "void":
        return _pyfreeling.VectorSGEntity_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorSGEntity_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_entity >::size_type":
        return _pyfreeling.VectorSGEntity_size(self)

    def swap(self, v: "VectorSGEntity") -> "void":
        return _pyfreeling.VectorSGEntity_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_entity >::iterator":
        return _pyfreeling.VectorSGEntity_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_entity >::iterator":
        return _pyfreeling.VectorSGEntity_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_entity >::reverse_iterator":
        return _pyfreeling.VectorSGEntity_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_entity >::reverse_iterator":
        return _pyfreeling.VectorSGEntity_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorSGEntity_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_entity >::allocator_type":
        return _pyfreeling.VectorSGEntity_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorSGEntity_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_entity >::iterator":
        return _pyfreeling.VectorSGEntity_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorSGEntity_swiginit(self, _pyfreeling.new_VectorSGEntity(*args))

    def push_back(self, x: "SG_entity") -> "void":
        return _pyfreeling.VectorSGEntity_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_entity >::value_type const &":
        return _pyfreeling.VectorSGEntity_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_entity >::value_type const &":
        return _pyfreeling.VectorSGEntity_back(self)

    def assign(self, n: "std::vector< freeling::semgraph::SG_entity >::size_type", x: "SG_entity") -> "void":
        return _pyfreeling.VectorSGEntity_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorSGEntity_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorSGEntity_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::semgraph::SG_entity >::size_type") -> "void":
        return _pyfreeling.VectorSGEntity_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_entity >::size_type":
        return _pyfreeling.VectorSGEntity_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorSGEntity

# Register VectorSGEntity in _pyfreeling:
_pyfreeling.VectorSGEntity_swigregister(VectorSGEntity)

class VectorSGFrame(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorSGFrame_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorSGFrame___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorSGFrame___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_frame >::size_type":
        return _pyfreeling.VectorSGFrame___len__(self)

    def __getslice__(self, i: "std::vector< freeling::semgraph::SG_frame >::difference_type", j: "std::vector< freeling::semgraph::SG_frame >::difference_type") -> "std::vector< freeling::semgraph::SG_frame,std::allocator< freeling::semgraph::SG_frame > > *":
        return _pyfreeling.VectorSGFrame___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorSGFrame___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< freeling::semgraph::SG_frame >::difference_type", j: "std::vector< freeling::semgraph::SG_frame >::difference_type") -> "void":
        return _pyfreeling.VectorSGFrame___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGFrame___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_frame >::value_type const &":
        return _pyfreeling.VectorSGFrame___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorSGFrame___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_frame >::value_type":
        return _pyfreeling.VectorSGFrame_pop(self)

    def append(self, x: "SG_frame") -> "void":
        return _pyfreeling.VectorSGFrame_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorSGFrame_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_frame >::size_type":
        return _pyfreeling.VectorSGFrame_size(self)

    def swap(self, v: "VectorSGFrame") -> "void":
        return _pyfreeling.VectorSGFrame_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_frame >::iterator":
        return _pyfreeling.VectorSGFrame_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_frame >::iterator":
        return _pyfreeling.VectorSGFrame_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_frame >::reverse_iterator":
        return _pyfreeling.VectorSGFrame_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_frame >::reverse_iterator":
        return _pyfreeling.VectorSGFrame_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorSGFrame_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_frame >::allocator_type":
        return _pyfreeling.VectorSGFrame_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorSGFrame_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_frame >::iterator":
        return _pyfreeling.VectorSGFrame_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorSGFrame_swiginit(self, _pyfreeling.new_VectorSGFrame(*args))

    def push_back(self, x: "SG_frame") -> "void":
        return _pyfreeling.VectorSGFrame_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_frame >::value_type const &":
        return _pyfreeling.VectorSGFrame_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_frame >::value_type const &":
        return _pyfreeling.VectorSGFrame_back(self)

    def assign(self, n: "std::vector< freeling::semgraph::SG_frame >::size_type", x: "SG_frame") -> "void":
        return _pyfreeling.VectorSGFrame_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorSGFrame_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorSGFrame_insert(self, *args)

    def reserve(self, n: "std::vector< freeling::semgraph::SG_frame >::size_type") -> "void":
        return _pyfreeling.VectorSGFrame_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_frame >::size_type":
        return _pyfreeling.VectorSGFrame_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorSGFrame

# Register VectorSGFrame in _pyfreeling:
_pyfreeling.VectorSGFrame_swigregister(VectorSGFrame)

class ListString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListString___bool__(self)

    def __len__(self) -> "std::list< std::wstring >::size_type":
        return _pyfreeling.ListString___len__(self)

    def __getslice__(self, i: "std::list< std::wstring >::difference_type", j: "std::list< std::wstring >::difference_type") -> "std::list< std::wstring,std::allocator< std::wstring > > *":
        return _pyfreeling.ListString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListString___setslice__(self, *args)

    def __delslice__(self, i: "std::list< std::wstring >::difference_type", j: "std::list< std::wstring >::difference_type") -> "void":
        return _pyfreeling.ListString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::wstring >::value_type const &":
        return _pyfreeling.ListString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListString___setitem__(self, *args)

    def pop(self) -> "std::list< std::wstring >::value_type":
        return _pyfreeling.ListString_pop(self)

    def append(self, x: "std::list< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.ListString_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListString_empty(self)

    def size(self) -> "std::list< std::wstring >::size_type":
        return _pyfreeling.ListString_size(self)

    def swap(self, v: "ListString") -> "void":
        return _pyfreeling.ListString_swap(self, v)

    def begin(self) -> "std::list< std::wstring >::iterator":
        return _pyfreeling.ListString_begin(self)

    def end(self) -> "std::list< std::wstring >::iterator":
        return _pyfreeling.ListString_end(self)

    def rbegin(self) -> "std::list< std::wstring >::reverse_iterator":
        return _pyfreeling.ListString_rbegin(self)

    def rend(self) -> "std::list< std::wstring >::reverse_iterator":
        return _pyfreeling.ListString_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListString_clear(self)

    def get_allocator(self) -> "std::list< std::wstring >::allocator_type":
        return _pyfreeling.ListString_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListString_pop_back(self)

    def erase(self, *args) -> "std::list< std::wstring >::iterator":
        return _pyfreeling.ListString_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListString_swiginit(self, _pyfreeling.new_ListString(*args))

    def push_back(self, x: "std::list< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.ListString_push_back(self, x)

    def front(self) -> "std::list< std::wstring >::value_type const &":
        return _pyfreeling.ListString_front(self)

    def back(self) -> "std::list< std::wstring >::value_type const &":
        return _pyfreeling.ListString_back(self)

    def assign(self, n: "std::list< std::wstring >::size_type", x: "std::list< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.ListString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListString_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListString_pop_front(self)

    def push_front(self, x: "std::list< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.ListString_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListString_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListString

# Register ListString in _pyfreeling:
_pyfreeling.ListString_swigregister(ListString)

class ListInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListInt___bool__(self)

    def __len__(self) -> "std::list< int >::size_type":
        return _pyfreeling.ListInt___len__(self)

    def __getslice__(self, i: "std::list< int >::difference_type", j: "std::list< int >::difference_type") -> "std::list< int,std::allocator< int > > *":
        return _pyfreeling.ListInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListInt___setslice__(self, *args)

    def __delslice__(self, i: "std::list< int >::difference_type", j: "std::list< int >::difference_type") -> "void":
        return _pyfreeling.ListInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< int >::value_type const &":
        return _pyfreeling.ListInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListInt___setitem__(self, *args)

    def pop(self) -> "std::list< int >::value_type":
        return _pyfreeling.ListInt_pop(self)

    def append(self, x: "std::list< int >::value_type const &") -> "void":
        return _pyfreeling.ListInt_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListInt_empty(self)

    def size(self) -> "std::list< int >::size_type":
        return _pyfreeling.ListInt_size(self)

    def swap(self, v: "ListInt") -> "void":
        return _pyfreeling.ListInt_swap(self, v)

    def begin(self) -> "std::list< int >::iterator":
        return _pyfreeling.ListInt_begin(self)

    def end(self) -> "std::list< int >::iterator":
        return _pyfreeling.ListInt_end(self)

    def rbegin(self) -> "std::list< int >::reverse_iterator":
        return _pyfreeling.ListInt_rbegin(self)

    def rend(self) -> "std::list< int >::reverse_iterator":
        return _pyfreeling.ListInt_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListInt_clear(self)

    def get_allocator(self) -> "std::list< int >::allocator_type":
        return _pyfreeling.ListInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListInt_pop_back(self)

    def erase(self, *args) -> "std::list< int >::iterator":
        return _pyfreeling.ListInt_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListInt_swiginit(self, _pyfreeling.new_ListInt(*args))

    def push_back(self, x: "std::list< int >::value_type const &") -> "void":
        return _pyfreeling.ListInt_push_back(self, x)

    def front(self) -> "std::list< int >::value_type const &":
        return _pyfreeling.ListInt_front(self)

    def back(self) -> "std::list< int >::value_type const &":
        return _pyfreeling.ListInt_back(self)

    def assign(self, n: "std::list< int >::size_type", x: "std::list< int >::value_type const &") -> "void":
        return _pyfreeling.ListInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListInt_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListInt_pop_front(self)

    def push_front(self, x: "std::list< int >::value_type const &") -> "void":
        return _pyfreeling.ListInt_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListInt_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListInt

# Register ListInt in _pyfreeling:
_pyfreeling.ListInt_swigregister(ListInt)

class VectorListInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorListInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorListInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorListInt___bool__(self)

    def __len__(self) -> "std::vector< std::list< int > >::size_type":
        return _pyfreeling.VectorListInt___len__(self)

    def __getslice__(self, i: "std::vector< std::list< int > >::difference_type", j: "std::vector< std::list< int > >::difference_type") -> "std::vector< std::list< int,std::allocator< int > >,std::allocator< std::list< int,std::allocator< int > > > > *":
        return _pyfreeling.VectorListInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorListInt___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::list< int > >::difference_type", j: "std::vector< std::list< int > >::difference_type") -> "void":
        return _pyfreeling.VectorListInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorListInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::list< int > >::value_type const &":
        return _pyfreeling.VectorListInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorListInt___setitem__(self, *args)

    def pop(self) -> "std::vector< std::list< int > >::value_type":
        return _pyfreeling.VectorListInt_pop(self)

    def append(self, x: "ListInt") -> "void":
        return _pyfreeling.VectorListInt_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorListInt_empty(self)

    def size(self) -> "std::vector< std::list< int > >::size_type":
        return _pyfreeling.VectorListInt_size(self)

    def swap(self, v: "VectorListInt") -> "void":
        return _pyfreeling.VectorListInt_swap(self, v)

    def begin(self) -> "std::vector< std::list< int > >::iterator":
        return _pyfreeling.VectorListInt_begin(self)

    def end(self) -> "std::vector< std::list< int > >::iterator":
        return _pyfreeling.VectorListInt_end(self)

    def rbegin(self) -> "std::vector< std::list< int > >::reverse_iterator":
        return _pyfreeling.VectorListInt_rbegin(self)

    def rend(self) -> "std::vector< std::list< int > >::reverse_iterator":
        return _pyfreeling.VectorListInt_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorListInt_clear(self)

    def get_allocator(self) -> "std::vector< std::list< int > >::allocator_type":
        return _pyfreeling.VectorListInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorListInt_pop_back(self)

    def erase(self, *args) -> "std::vector< std::list< int > >::iterator":
        return _pyfreeling.VectorListInt_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorListInt_swiginit(self, _pyfreeling.new_VectorListInt(*args))

    def push_back(self, x: "ListInt") -> "void":
        return _pyfreeling.VectorListInt_push_back(self, x)

    def front(self) -> "std::vector< std::list< int > >::value_type const &":
        return _pyfreeling.VectorListInt_front(self)

    def back(self) -> "std::vector< std::list< int > >::value_type const &":
        return _pyfreeling.VectorListInt_back(self)

    def assign(self, n: "std::vector< std::list< int > >::size_type", x: "ListInt") -> "void":
        return _pyfreeling.VectorListInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorListInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorListInt_insert(self, *args)

    def reserve(self, n: "std::vector< std::list< int > >::size_type") -> "void":
        return _pyfreeling.VectorListInt_reserve(self, n)

    def capacity(self) -> "std::vector< std::list< int > >::size_type":
        return _pyfreeling.VectorListInt_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorListInt

# Register VectorListInt in _pyfreeling:
_pyfreeling.VectorListInt_swigregister(VectorListInt)

class VectorListString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorListString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorListString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorListString___bool__(self)

    def __len__(self) -> "std::vector< std::list< std::wstring > >::size_type":
        return _pyfreeling.VectorListString___len__(self)

    def __getslice__(self, i: "std::vector< std::list< std::wstring > >::difference_type", j: "std::vector< std::list< std::wstring > >::difference_type") -> "std::vector< std::list< std::wstring,std::allocator< std::wstring > >,std::allocator< std::list< std::wstring,std::allocator< std::wstring > > > > *":
        return _pyfreeling.VectorListString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorListString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::list< std::wstring > >::difference_type", j: "std::vector< std::list< std::wstring > >::difference_type") -> "void":
        return _pyfreeling.VectorListString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorListString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::list< std::wstring > >::value_type const &":
        return _pyfreeling.VectorListString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorListString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::list< std::wstring > >::value_type":
        return _pyfreeling.VectorListString_pop(self)

    def append(self, x: "ListString") -> "void":
        return _pyfreeling.VectorListString_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorListString_empty(self)

    def size(self) -> "std::vector< std::list< std::wstring > >::size_type":
        return _pyfreeling.VectorListString_size(self)

    def swap(self, v: "VectorListString") -> "void":
        return _pyfreeling.VectorListString_swap(self, v)

    def begin(self) -> "std::vector< std::list< std::wstring > >::iterator":
        return _pyfreeling.VectorListString_begin(self)

    def end(self) -> "std::vector< std::list< std::wstring > >::iterator":
        return _pyfreeling.VectorListString_end(self)

    def rbegin(self) -> "std::vector< std::list< std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorListString_rbegin(self)

    def rend(self) -> "std::vector< std::list< std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorListString_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorListString_clear(self)

    def get_allocator(self) -> "std::vector< std::list< std::wstring > >::allocator_type":
        return _pyfreeling.VectorListString_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorListString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::list< std::wstring > >::iterator":
        return _pyfreeling.VectorListString_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorListString_swiginit(self, _pyfreeling.new_VectorListString(*args))

    def push_back(self, x: "ListString") -> "void":
        return _pyfreeling.VectorListString_push_back(self, x)

    def front(self) -> "std::vector< std::list< std::wstring > >::value_type const &":
        return _pyfreeling.VectorListString_front(self)

    def back(self) -> "std::vector< std::list< std::wstring > >::value_type const &":
        return _pyfreeling.VectorListString_back(self)

    def assign(self, n: "std::vector< std::list< std::wstring > >::size_type", x: "ListString") -> "void":
        return _pyfreeling.VectorListString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorListString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorListString_insert(self, *args)

    def reserve(self, n: "std::vector< std::list< std::wstring > >::size_type") -> "void":
        return _pyfreeling.VectorListString_reserve(self, n)

    def capacity(self) -> "std::vector< std::list< std::wstring > >::size_type":
        return _pyfreeling.VectorListString_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorListString

# Register VectorListString in _pyfreeling:
_pyfreeling.VectorListString_swigregister(VectorListString)

class VectorString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorString___bool__(self)

    def __len__(self) -> "std::vector< std::wstring >::size_type":
        return _pyfreeling.VectorString___len__(self)

    def __getslice__(self, i: "std::vector< std::wstring >::difference_type", j: "std::vector< std::wstring >::difference_type") -> "std::vector< std::wstring,std::allocator< std::wstring > > *":
        return _pyfreeling.VectorString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::wstring >::difference_type", j: "std::vector< std::wstring >::difference_type") -> "void":
        return _pyfreeling.VectorString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::wstring >::value_type const &":
        return _pyfreeling.VectorString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::wstring >::value_type":
        return _pyfreeling.VectorString_pop(self)

    def append(self, x: "std::vector< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.VectorString_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorString_empty(self)

    def size(self) -> "std::vector< std::wstring >::size_type":
        return _pyfreeling.VectorString_size(self)

    def swap(self, v: "VectorString") -> "void":
        return _pyfreeling.VectorString_swap(self, v)

    def begin(self) -> "std::vector< std::wstring >::iterator":
        return _pyfreeling.VectorString_begin(self)

    def end(self) -> "std::vector< std::wstring >::iterator":
        return _pyfreeling.VectorString_end(self)

    def rbegin(self) -> "std::vector< std::wstring >::reverse_iterator":
        return _pyfreeling.VectorString_rbegin(self)

    def rend(self) -> "std::vector< std::wstring >::reverse_iterator":
        return _pyfreeling.VectorString_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorString_clear(self)

    def get_allocator(self) -> "std::vector< std::wstring >::allocator_type":
        return _pyfreeling.VectorString_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::wstring >::iterator":
        return _pyfreeling.VectorString_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorString_swiginit(self, _pyfreeling.new_VectorString(*args))

    def push_back(self, x: "std::vector< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.VectorString_push_back(self, x)

    def front(self) -> "std::vector< std::wstring >::value_type const &":
        return _pyfreeling.VectorString_front(self)

    def back(self) -> "std::vector< std::wstring >::value_type const &":
        return _pyfreeling.VectorString_back(self)

    def assign(self, n: "std::vector< std::wstring >::size_type", x: "std::vector< std::wstring >::value_type const &") -> "void":
        return _pyfreeling.VectorString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorString_insert(self, *args)

    def reserve(self, n: "std::vector< std::wstring >::size_type") -> "void":
        return _pyfreeling.VectorString_reserve(self, n)

    def capacity(self) -> "std::vector< std::wstring >::size_type":
        return _pyfreeling.VectorString_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorString

# Register VectorString in _pyfreeling:
_pyfreeling.VectorString_swigregister(VectorString)

class VectorSetString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorSetString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorSetString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorSetString___bool__(self)

    def __len__(self) -> "std::vector< std::set< std::wstring > >::size_type":
        return _pyfreeling.VectorSetString___len__(self)

    def __getslice__(self, i: "std::vector< std::set< std::wstring > >::difference_type", j: "std::vector< std::set< std::wstring > >::difference_type") -> "std::vector< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > >,std::allocator< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > > > > *":
        return _pyfreeling.VectorSetString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorSetString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::set< std::wstring > >::difference_type", j: "std::vector< std::set< std::wstring > >::difference_type") -> "void":
        return _pyfreeling.VectorSetString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorSetString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::set< std::wstring > >::value_type const &":
        return _pyfreeling.VectorSetString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorSetString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::set< std::wstring > >::value_type":
        return _pyfreeling.VectorSetString_pop(self)

    def append(self, x: "SetString") -> "void":
        return _pyfreeling.VectorSetString_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorSetString_empty(self)

    def size(self) -> "std::vector< std::set< std::wstring > >::size_type":
        return _pyfreeling.VectorSetString_size(self)

    def swap(self, v: "VectorSetString") -> "void":
        return _pyfreeling.VectorSetString_swap(self, v)

    def begin(self) -> "std::vector< std::set< std::wstring > >::iterator":
        return _pyfreeling.VectorSetString_begin(self)

    def end(self) -> "std::vector< std::set< std::wstring > >::iterator":
        return _pyfreeling.VectorSetString_end(self)

    def rbegin(self) -> "std::vector< std::set< std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorSetString_rbegin(self)

    def rend(self) -> "std::vector< std::set< std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorSetString_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorSetString_clear(self)

    def get_allocator(self) -> "std::vector< std::set< std::wstring > >::allocator_type":
        return _pyfreeling.VectorSetString_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorSetString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::set< std::wstring > >::iterator":
        return _pyfreeling.VectorSetString_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorSetString_swiginit(self, _pyfreeling.new_VectorSetString(*args))

    def push_back(self, x: "SetString") -> "void":
        return _pyfreeling.VectorSetString_push_back(self, x)

    def front(self) -> "std::vector< std::set< std::wstring > >::value_type const &":
        return _pyfreeling.VectorSetString_front(self)

    def back(self) -> "std::vector< std::set< std::wstring > >::value_type const &":
        return _pyfreeling.VectorSetString_back(self)

    def assign(self, n: "std::vector< std::set< std::wstring > >::size_type", x: "SetString") -> "void":
        return _pyfreeling.VectorSetString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorSetString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorSetString_insert(self, *args)

    def reserve(self, n: "std::vector< std::set< std::wstring > >::size_type") -> "void":
        return _pyfreeling.VectorSetString_reserve(self, n)

    def capacity(self) -> "std::vector< std::set< std::wstring > >::size_type":
        return _pyfreeling.VectorSetString_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorSetString

# Register VectorSetString in _pyfreeling:
_pyfreeling.VectorSetString_swigregister(VectorSetString)

class VectorSetInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorSetInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorSetInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorSetInt___bool__(self)

    def __len__(self) -> "std::vector< std::set< int > >::size_type":
        return _pyfreeling.VectorSetInt___len__(self)

    def __getslice__(self, i: "std::vector< std::set< int > >::difference_type", j: "std::vector< std::set< int > >::difference_type") -> "std::vector< std::set< int,std::less< int >,std::allocator< int > >,std::allocator< std::set< int,std::less< int >,std::allocator< int > > > > *":
        return _pyfreeling.VectorSetInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorSetInt___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::set< int > >::difference_type", j: "std::vector< std::set< int > >::difference_type") -> "void":
        return _pyfreeling.VectorSetInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorSetInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::set< int > >::value_type const &":
        return _pyfreeling.VectorSetInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorSetInt___setitem__(self, *args)

    def pop(self) -> "std::vector< std::set< int > >::value_type":
        return _pyfreeling.VectorSetInt_pop(self)

    def append(self, x: "std::vector< std::set< int > >::value_type const &") -> "void":
        return _pyfreeling.VectorSetInt_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorSetInt_empty(self)

    def size(self) -> "std::vector< std::set< int > >::size_type":
        return _pyfreeling.VectorSetInt_size(self)

    def swap(self, v: "VectorSetInt") -> "void":
        return _pyfreeling.VectorSetInt_swap(self, v)

    def begin(self) -> "std::vector< std::set< int > >::iterator":
        return _pyfreeling.VectorSetInt_begin(self)

    def end(self) -> "std::vector< std::set< int > >::iterator":
        return _pyfreeling.VectorSetInt_end(self)

    def rbegin(self) -> "std::vector< std::set< int > >::reverse_iterator":
        return _pyfreeling.VectorSetInt_rbegin(self)

    def rend(self) -> "std::vector< std::set< int > >::reverse_iterator":
        return _pyfreeling.VectorSetInt_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorSetInt_clear(self)

    def get_allocator(self) -> "std::vector< std::set< int > >::allocator_type":
        return _pyfreeling.VectorSetInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorSetInt_pop_back(self)

    def erase(self, *args) -> "std::vector< std::set< int > >::iterator":
        return _pyfreeling.VectorSetInt_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorSetInt_swiginit(self, _pyfreeling.new_VectorSetInt(*args))

    def push_back(self, x: "std::vector< std::set< int > >::value_type const &") -> "void":
        return _pyfreeling.VectorSetInt_push_back(self, x)

    def front(self) -> "std::vector< std::set< int > >::value_type const &":
        return _pyfreeling.VectorSetInt_front(self)

    def back(self) -> "std::vector< std::set< int > >::value_type const &":
        return _pyfreeling.VectorSetInt_back(self)

    def assign(self, n: "std::vector< std::set< int > >::size_type", x: "std::vector< std::set< int > >::value_type const &") -> "void":
        return _pyfreeling.VectorSetInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorSetInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorSetInt_insert(self, *args)

    def reserve(self, n: "std::vector< std::set< int > >::size_type") -> "void":
        return _pyfreeling.VectorSetInt_reserve(self, n)

    def capacity(self) -> "std::vector< std::set< int > >::size_type":
        return _pyfreeling.VectorSetInt_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorSetInt

# Register VectorSetInt in _pyfreeling:
_pyfreeling.VectorSetInt_swigregister(VectorSetInt)

class SetString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.SetString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.SetString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.SetString___bool__(self)

    def __len__(self) -> "std::set< std::wstring >::size_type":
        return _pyfreeling.SetString___len__(self)

    def append(self, x: "std::set< std::wstring >::value_type") -> "void":
        return _pyfreeling.SetString_append(self, x)

    def __contains__(self, x: "std::set< std::wstring >::value_type") -> "bool":
        return _pyfreeling.SetString___contains__(self, x)

    def __getitem__(self, i: "std::set< std::wstring >::difference_type") -> "std::set< std::wstring >::value_type":
        return _pyfreeling.SetString___getitem__(self, i)

    def add(self, x: "std::set< std::wstring >::value_type") -> "void":
        return _pyfreeling.SetString_add(self, x)

    def discard(self, x: "std::set< std::wstring >::value_type") -> "void":
        return _pyfreeling.SetString_discard(self, x)

    def __init__(self, *args):
        _pyfreeling.SetString_swiginit(self, _pyfreeling.new_SetString(*args))

    def empty(self) -> "bool":
        return _pyfreeling.SetString_empty(self)

    def size(self) -> "std::set< std::wstring >::size_type":
        return _pyfreeling.SetString_size(self)

    def clear(self) -> "void":
        return _pyfreeling.SetString_clear(self)

    def swap(self, v: "SetString") -> "void":
        return _pyfreeling.SetString_swap(self, v)

    def count(self, x: "std::set< std::wstring >::key_type const &") -> "std::set< std::wstring >::size_type":
        return _pyfreeling.SetString_count(self, x)

    def begin(self) -> "std::set< std::wstring >::iterator":
        return _pyfreeling.SetString_begin(self)

    def end(self) -> "std::set< std::wstring >::iterator":
        return _pyfreeling.SetString_end(self)

    def rbegin(self) -> "std::set< std::wstring >::reverse_iterator":
        return _pyfreeling.SetString_rbegin(self)

    def rend(self) -> "std::set< std::wstring >::reverse_iterator":
        return _pyfreeling.SetString_rend(self)

    def erase(self, *args) -> "void":
        return _pyfreeling.SetString_erase(self, *args)

    def find(self, x: "std::set< std::wstring >::key_type const &") -> "std::set< std::wstring >::iterator":
        return _pyfreeling.SetString_find(self, x)

    def lower_bound(self, x: "std::set< std::wstring >::key_type const &") -> "std::set< std::wstring >::iterator":
        return _pyfreeling.SetString_lower_bound(self, x)

    def upper_bound(self, x: "std::set< std::wstring >::key_type const &") -> "std::set< std::wstring >::iterator":
        return _pyfreeling.SetString_upper_bound(self, x)

    def equal_range(self, x: "std::set< std::wstring >::key_type const &") -> "std::pair< std::set< std::wstring >::iterator,std::set< std::wstring >::iterator >":
        return _pyfreeling.SetString_equal_range(self, x)

    def insert(self, __x: "std::set< std::wstring >::value_type const &") -> "std::pair< std::set< std::wstring >::iterator,bool >":
        return _pyfreeling.SetString_insert(self, __x)
    __swig_destroy__ = _pyfreeling.delete_SetString

# Register SetString in _pyfreeling:
_pyfreeling.SetString_swigregister(SetString)

class PairDoubleString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.PairDoubleString_swiginit(self, _pyfreeling.new_PairDoubleString(*args))
    first = property(_pyfreeling.PairDoubleString_first_get, _pyfreeling.PairDoubleString_first_set)
    second = property(_pyfreeling.PairDoubleString_second_get, _pyfreeling.PairDoubleString_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyfreeling.delete_PairDoubleString

# Register PairDoubleString in _pyfreeling:
_pyfreeling.PairDoubleString_swigregister(PairDoubleString)

class VectorPairDoubleString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorPairDoubleString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorPairDoubleString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorPairDoubleString___bool__(self)

    def __len__(self) -> "std::vector< std::pair< double,std::wstring > >::size_type":
        return _pyfreeling.VectorPairDoubleString___len__(self)

    def __getslice__(self, i: "std::vector< std::pair< double,std::wstring > >::difference_type", j: "std::vector< std::pair< double,std::wstring > >::difference_type") -> "std::vector< std::pair< double,std::wstring >,std::allocator< std::pair< double,std::wstring > > > *":
        return _pyfreeling.VectorPairDoubleString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorPairDoubleString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::pair< double,std::wstring > >::difference_type", j: "std::vector< std::pair< double,std::wstring > >::difference_type") -> "void":
        return _pyfreeling.VectorPairDoubleString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorPairDoubleString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< double,std::wstring > >::value_type const &":
        return _pyfreeling.VectorPairDoubleString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorPairDoubleString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< double,std::wstring > >::value_type":
        return _pyfreeling.VectorPairDoubleString_pop(self)

    def append(self, x: "PairDoubleString") -> "void":
        return _pyfreeling.VectorPairDoubleString_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorPairDoubleString_empty(self)

    def size(self) -> "std::vector< std::pair< double,std::wstring > >::size_type":
        return _pyfreeling.VectorPairDoubleString_size(self)

    def swap(self, v: "VectorPairDoubleString") -> "void":
        return _pyfreeling.VectorPairDoubleString_swap(self, v)

    def begin(self) -> "std::vector< std::pair< double,std::wstring > >::iterator":
        return _pyfreeling.VectorPairDoubleString_begin(self)

    def end(self) -> "std::vector< std::pair< double,std::wstring > >::iterator":
        return _pyfreeling.VectorPairDoubleString_end(self)

    def rbegin(self) -> "std::vector< std::pair< double,std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorPairDoubleString_rbegin(self)

    def rend(self) -> "std::vector< std::pair< double,std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorPairDoubleString_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorPairDoubleString_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< double,std::wstring > >::allocator_type":
        return _pyfreeling.VectorPairDoubleString_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorPairDoubleString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< double,std::wstring > >::iterator":
        return _pyfreeling.VectorPairDoubleString_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorPairDoubleString_swiginit(self, _pyfreeling.new_VectorPairDoubleString(*args))

    def push_back(self, x: "PairDoubleString") -> "void":
        return _pyfreeling.VectorPairDoubleString_push_back(self, x)

    def front(self) -> "std::vector< std::pair< double,std::wstring > >::value_type const &":
        return _pyfreeling.VectorPairDoubleString_front(self)

    def back(self) -> "std::vector< std::pair< double,std::wstring > >::value_type const &":
        return _pyfreeling.VectorPairDoubleString_back(self)

    def assign(self, n: "std::vector< std::pair< double,std::wstring > >::size_type", x: "PairDoubleString") -> "void":
        return _pyfreeling.VectorPairDoubleString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorPairDoubleString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorPairDoubleString_insert(self, *args)

    def reserve(self, n: "std::vector< std::pair< double,std::wstring > >::size_type") -> "void":
        return _pyfreeling.VectorPairDoubleString_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< double,std::wstring > >::size_type":
        return _pyfreeling.VectorPairDoubleString_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorPairDoubleString

# Register VectorPairDoubleString in _pyfreeling:
_pyfreeling.VectorPairDoubleString_swigregister(VectorPairDoubleString)

class PairStringString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.PairStringString_swiginit(self, _pyfreeling.new_PairStringString(*args))
    first = property(_pyfreeling.PairStringString_first_get, _pyfreeling.PairStringString_first_set)
    second = property(_pyfreeling.PairStringString_second_get, _pyfreeling.PairStringString_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyfreeling.delete_PairStringString

# Register PairStringString in _pyfreeling:
_pyfreeling.PairStringString_swigregister(PairStringString)

class VectorPairStringString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.VectorPairStringString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.VectorPairStringString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.VectorPairStringString___bool__(self)

    def __len__(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type":
        return _pyfreeling.VectorPairStringString___len__(self)

    def __getslice__(self, i: "std::vector< std::pair< std::wstring,std::wstring > >::difference_type", j: "std::vector< std::pair< std::wstring,std::wstring > >::difference_type") -> "std::vector< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > > *":
        return _pyfreeling.VectorPairStringString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.VectorPairStringString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::pair< std::wstring,std::wstring > >::difference_type", j: "std::vector< std::pair< std::wstring,std::wstring > >::difference_type") -> "void":
        return _pyfreeling.VectorPairStringString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.VectorPairStringString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &":
        return _pyfreeling.VectorPairStringString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.VectorPairStringString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type":
        return _pyfreeling.VectorPairStringString_pop(self)

    def append(self, x: "PairStringString") -> "void":
        return _pyfreeling.VectorPairStringString_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.VectorPairStringString_empty(self)

    def size(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type":
        return _pyfreeling.VectorPairStringString_size(self)

    def swap(self, v: "VectorPairStringString") -> "void":
        return _pyfreeling.VectorPairStringString_swap(self, v)

    def begin(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator":
        return _pyfreeling.VectorPairStringString_begin(self)

    def end(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator":
        return _pyfreeling.VectorPairStringString_end(self)

    def rbegin(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorPairStringString_rbegin(self)

    def rend(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::reverse_iterator":
        return _pyfreeling.VectorPairStringString_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.VectorPairStringString_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::allocator_type":
        return _pyfreeling.VectorPairStringString_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.VectorPairStringString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator":
        return _pyfreeling.VectorPairStringString_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.VectorPairStringString_swiginit(self, _pyfreeling.new_VectorPairStringString(*args))

    def push_back(self, x: "PairStringString") -> "void":
        return _pyfreeling.VectorPairStringString_push_back(self, x)

    def front(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &":
        return _pyfreeling.VectorPairStringString_front(self)

    def back(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &":
        return _pyfreeling.VectorPairStringString_back(self)

    def assign(self, n: "std::vector< std::pair< std::wstring,std::wstring > >::size_type", x: "PairStringString") -> "void":
        return _pyfreeling.VectorPairStringString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.VectorPairStringString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.VectorPairStringString_insert(self, *args)

    def reserve(self, n: "std::vector< std::pair< std::wstring,std::wstring > >::size_type") -> "void":
        return _pyfreeling.VectorPairStringString_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type":
        return _pyfreeling.VectorPairStringString_capacity(self)
    __swig_destroy__ = _pyfreeling.delete_VectorPairStringString

# Register VectorPairStringString in _pyfreeling:
_pyfreeling.VectorPairStringString_swigregister(VectorPairStringString)

class PairStringInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.PairStringInt_swiginit(self, _pyfreeling.new_PairStringInt(*args))
    first = property(_pyfreeling.PairStringInt_first_get, _pyfreeling.PairStringInt_first_set)
    second = property(_pyfreeling.PairStringInt_second_get, _pyfreeling.PairStringInt_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyfreeling.delete_PairStringInt

# Register PairStringInt in _pyfreeling:
_pyfreeling.PairStringInt_swigregister(PairStringInt)

class PairStringDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.PairStringDouble_swiginit(self, _pyfreeling.new_PairStringDouble(*args))
    first = property(_pyfreeling.PairStringDouble_first_get, _pyfreeling.PairStringDouble_first_set)
    second = property(_pyfreeling.PairStringDouble_second_get, _pyfreeling.PairStringDouble_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyfreeling.delete_PairStringDouble

# Register PairStringDouble in _pyfreeling:
_pyfreeling.PairStringDouble_swigregister(PairStringDouble)

class ListPairStringDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pyfreeling.ListPairStringDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pyfreeling.ListPairStringDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pyfreeling.ListPairStringDouble___bool__(self)

    def __len__(self) -> "std::list< std::pair< std::wstring,double > >::size_type":
        return _pyfreeling.ListPairStringDouble___len__(self)

    def __getslice__(self, i: "std::list< std::pair< std::wstring,double > >::difference_type", j: "std::list< std::pair< std::wstring,double > >::difference_type") -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > > *":
        return _pyfreeling.ListPairStringDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pyfreeling.ListPairStringDouble___setslice__(self, *args)

    def __delslice__(self, i: "std::list< std::pair< std::wstring,double > >::difference_type", j: "std::list< std::pair< std::wstring,double > >::difference_type") -> "void":
        return _pyfreeling.ListPairStringDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pyfreeling.ListPairStringDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::pair< std::wstring,double > >::value_type const &":
        return _pyfreeling.ListPairStringDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pyfreeling.ListPairStringDouble___setitem__(self, *args)

    def pop(self) -> "std::list< std::pair< std::wstring,double > >::value_type":
        return _pyfreeling.ListPairStringDouble_pop(self)

    def append(self, x: "PairStringDouble") -> "void":
        return _pyfreeling.ListPairStringDouble_append(self, x)

    def empty(self) -> "bool":
        return _pyfreeling.ListPairStringDouble_empty(self)

    def size(self) -> "std::list< std::pair< std::wstring,double > >::size_type":
        return _pyfreeling.ListPairStringDouble_size(self)

    def swap(self, v: "ListPairStringDouble") -> "void":
        return _pyfreeling.ListPairStringDouble_swap(self, v)

    def begin(self) -> "std::list< std::pair< std::wstring,double > >::iterator":
        return _pyfreeling.ListPairStringDouble_begin(self)

    def end(self) -> "std::list< std::pair< std::wstring,double > >::iterator":
        return _pyfreeling.ListPairStringDouble_end(self)

    def rbegin(self) -> "std::list< std::pair< std::wstring,double > >::reverse_iterator":
        return _pyfreeling.ListPairStringDouble_rbegin(self)

    def rend(self) -> "std::list< std::pair< std::wstring,double > >::reverse_iterator":
        return _pyfreeling.ListPairStringDouble_rend(self)

    def clear(self) -> "void":
        return _pyfreeling.ListPairStringDouble_clear(self)

    def get_allocator(self) -> "std::list< std::pair< std::wstring,double > >::allocator_type":
        return _pyfreeling.ListPairStringDouble_get_allocator(self)

    def pop_back(self) -> "void":
        return _pyfreeling.ListPairStringDouble_pop_back(self)

    def erase(self, *args) -> "std::list< std::pair< std::wstring,double > >::iterator":
        return _pyfreeling.ListPairStringDouble_erase(self, *args)

    def __init__(self, *args):
        _pyfreeling.ListPairStringDouble_swiginit(self, _pyfreeling.new_ListPairStringDouble(*args))

    def push_back(self, x: "PairStringDouble") -> "void":
        return _pyfreeling.ListPairStringDouble_push_back(self, x)

    def front(self) -> "std::list< std::pair< std::wstring,double > >::value_type const &":
        return _pyfreeling.ListPairStringDouble_front(self)

    def back(self) -> "std::list< std::pair< std::wstring,double > >::value_type const &":
        return _pyfreeling.ListPairStringDouble_back(self)

    def assign(self, n: "std::list< std::pair< std::wstring,double > >::size_type", x: "PairStringDouble") -> "void":
        return _pyfreeling.ListPairStringDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pyfreeling.ListPairStringDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pyfreeling.ListPairStringDouble_insert(self, *args)

    def pop_front(self) -> "void":
        return _pyfreeling.ListPairStringDouble_pop_front(self)

    def push_front(self, x: "PairStringDouble") -> "void":
        return _pyfreeling.ListPairStringDouble_push_front(self, x)

    def reverse(self) -> "void":
        return _pyfreeling.ListPairStringDouble_reverse(self)
    __swig_destroy__ = _pyfreeling.delete_ListPairStringDouble

# Register ListPairStringDouble in _pyfreeling:
_pyfreeling.ListPairStringDouble_swigregister(ListPairStringDouble)

class TreeOfNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeOfNode_swiginit(self, _pyfreeling.new_TreeOfNode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeOfNode

    def clear(self) -> "void":
        return _pyfreeling.TreeOfNode_clear(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeOfNode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeOfNode_empty(self)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeOfNode_num_children(self)

    def has_ancestor(self, arg2: "TreeOfNode") -> "bool":
        return _pyfreeling.TreeOfNode_has_ancestor(self, arg2)

    def add_child(self, t: "TreeOfNode", last: "bool"=True) -> "void":
        return _pyfreeling.TreeOfNode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _pyfreeling.TreeOfNode_hang_child(self, *args)

    def nth_child(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _pyfreeling.TreeOfNode_nth_child(self, *args)

    def nth_child_ref(self, *args) -> "freeling::tree< freeling::node > const &":
        return _pyfreeling.TreeOfNode_nth_child_ref(self, *args)

    def get_parent(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator":
        return _pyfreeling.TreeOfNode_get_parent(self, *args)

    def begin(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator":
        return _pyfreeling.TreeOfNode_begin(self, *args)

    def end(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator":
        return _pyfreeling.TreeOfNode_end(self, *args)

    def sibling_begin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _pyfreeling.TreeOfNode_sibling_begin(self, *args)

    def sibling_end(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _pyfreeling.TreeOfNode_sibling_end(self, *args)

    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _pyfreeling.TreeOfNode_sibling_rbegin(self, *args)

    def sibling_rend(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _pyfreeling.TreeOfNode_sibling_rend(self, *args)

# Register TreeOfNode in _pyfreeling:
_pyfreeling.TreeOfNode_swigregister(TreeOfNode)

class TreeOfDepnode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeOfDepnode_swiginit(self, _pyfreeling.new_TreeOfDepnode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeOfDepnode

    def clear(self) -> "void":
        return _pyfreeling.TreeOfDepnode_clear(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeOfDepnode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeOfDepnode_empty(self)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeOfDepnode_num_children(self)

    def has_ancestor(self, arg2: "TreeOfDepnode") -> "bool":
        return _pyfreeling.TreeOfDepnode_has_ancestor(self, arg2)

    def add_child(self, t: "TreeOfDepnode", last: "bool"=True) -> "void":
        return _pyfreeling.TreeOfDepnode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _pyfreeling.TreeOfDepnode_hang_child(self, *args)

    def nth_child(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _pyfreeling.TreeOfDepnode_nth_child(self, *args)

    def nth_child_ref(self, *args) -> "freeling::tree< freeling::depnode > const &":
        return _pyfreeling.TreeOfDepnode_nth_child_ref(self, *args)

    def get_parent(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator":
        return _pyfreeling.TreeOfDepnode_get_parent(self, *args)

    def begin(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator":
        return _pyfreeling.TreeOfDepnode_begin(self, *args)

    def end(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator":
        return _pyfreeling.TreeOfDepnode_end(self, *args)

    def sibling_begin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _pyfreeling.TreeOfDepnode_sibling_begin(self, *args)

    def sibling_end(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _pyfreeling.TreeOfDepnode_sibling_end(self, *args)

    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _pyfreeling.TreeOfDepnode_sibling_rbegin(self, *args)

    def sibling_rend(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _pyfreeling.TreeOfDepnode_sibling_rend(self, *args)

# Register TreeOfDepnode in _pyfreeling:
_pyfreeling.TreeOfDepnode_swigregister(TreeOfDepnode)

class TreePreorderIteratorNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreePreorderIteratorNode_swiginit(self, _pyfreeling.new_TreePreorderIteratorNode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreePreorderIteratorNode

    def incr(self) -> "void":
        return _pyfreeling.TreePreorderIteratorNode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreePreorderIteratorNode_decr(self)

    def __eq__(self, t: "TreePreorderIteratorNode") -> "bool":
        return _pyfreeling.TreePreorderIteratorNode___eq__(self, t)

    def __ne__(self, t: "TreePreorderIteratorNode") -> "bool":
        return _pyfreeling.TreePreorderIteratorNode___ne__(self, t)

    def __ref__(self) -> "freeling::node &":
        return _pyfreeling.TreePreorderIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node *":
        return _pyfreeling.TreePreorderIteratorNode___deref__(self)

    def get_info(self) -> "freeling::node *":
        return _pyfreeling.TreePreorderIteratorNode_get_info(self)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_empty(self)

    def has_ancestor(self, p: "TreeOfNode") -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreePreorderIteratorNode_num_children(self)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_get_parent(self)

    def nth_child(self, arg2: "unsigned int") -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: "unsigned int") -> "freeling::tree< freeling::node > &":
        return _pyfreeling.TreePreorderIteratorNode_nth_child_ref(self, arg2)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreePreorderIteratorNode_sibling_rend(self)

    def add_child(self, t: "TreeOfNode", last: "bool"=True) -> "void":
        return _pyfreeling.TreePreorderIteratorNode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _pyfreeling.TreePreorderIteratorNode_hang_child(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreePreorderIteratorNode_get_node_id(self)

    def set_node_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreePreorderIteratorNode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreePreorderIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreePreorderIteratorNode_get_word(self, *args)

    def set_label(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreePreorderIteratorNode_set_label(self, arg2)

    def set_word(self, arg2: "word") -> "void":
        return _pyfreeling.TreePreorderIteratorNode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_is_head(self)

    def set_head(self, arg2: "bool const") -> "void":
        return _pyfreeling.TreePreorderIteratorNode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorNode_is_chunk(self)

    def set_chunk(self, arg2: "int const") -> "void":
        return _pyfreeling.TreePreorderIteratorNode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreePreorderIteratorNode_get_chunk_ord(self)

# Register TreePreorderIteratorNode in _pyfreeling:
_pyfreeling.TreePreorderIteratorNode_swigregister(TreePreorderIteratorNode)

class TreeSiblingIteratorNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeSiblingIteratorNode_swiginit(self, _pyfreeling.new_TreeSiblingIteratorNode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeSiblingIteratorNode

    def incr(self) -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_decr(self)

    def __ref__(self) -> "freeling::node &":
        return _pyfreeling.TreeSiblingIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node *":
        return _pyfreeling.TreeSiblingIteratorNode___deref__(self)

    def get_info(self) -> "freeling::node *":
        return _pyfreeling.TreeSiblingIteratorNode_get_info(self)

    def __eq__(self, t: "TreeSiblingIteratorNode") -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode___eq__(self, t)

    def __ne__(self, t: "TreeSiblingIteratorNode") -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode___ne__(self, t)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_get_parent(self)

    def nth_child(self, arg2: "unsigned int") -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: "unsigned int") -> "freeling::tree< freeling::node > &":
        return _pyfreeling.TreeSiblingIteratorNode_nth_child_ref(self, arg2)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_empty(self)

    def has_ancestor(self, p: "TreeOfNode") -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeSiblingIteratorNode_num_children(self)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeSiblingIteratorNode_sibling_rend(self)

    def add_child(self, t: "TreeOfNode", last: "bool"=True) -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_hang_child(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreeSiblingIteratorNode_get_node_id(self)

    def set_node_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreeSiblingIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreeSiblingIteratorNode_get_word(self, *args)

    def set_label(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_set_label(self, arg2)

    def set_word(self, arg2: "word") -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_is_head(self)

    def set_head(self, arg2: "bool const") -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorNode_is_chunk(self)

    def set_chunk(self, arg2: "int const") -> "void":
        return _pyfreeling.TreeSiblingIteratorNode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreeSiblingIteratorNode_get_chunk_ord(self)

# Register TreeSiblingIteratorNode in _pyfreeling:
_pyfreeling.TreeSiblingIteratorNode_swigregister(TreeSiblingIteratorNode)

class TreePreorderIteratorDepnode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreePreorderIteratorDepnode_swiginit(self, _pyfreeling.new_TreePreorderIteratorDepnode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreePreorderIteratorDepnode

    def incr(self) -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_decr(self)

    def __eq__(self, t: "TreePreorderIteratorDepnode") -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode___eq__(self, t)

    def __ne__(self, t: "TreePreorderIteratorDepnode") -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode___ne__(self, t)

    def __ref__(self) -> "freeling::depnode &":
        return _pyfreeling.TreePreorderIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode *":
        return _pyfreeling.TreePreorderIteratorDepnode___deref__(self)

    def get_info(self) -> "freeling::depnode *":
        return _pyfreeling.TreePreorderIteratorDepnode_get_info(self)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_empty(self)

    def has_ancestor(self, p: "TreeOfDepnode") -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreePreorderIteratorDepnode_num_children(self)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_get_parent(self)

    def nth_child(self, arg2: "unsigned int") -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: "unsigned int") -> "freeling::tree< freeling::depnode > &":
        return _pyfreeling.TreePreorderIteratorDepnode_nth_child_ref(self, arg2)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreePreorderIteratorDepnode_sibling_rend(self)

    def add_child(self, t: "TreeOfDepnode", last: "bool"=True) -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_hang_child(self, *args)

    def set_link(self, arg2: "TreePreorderIteratorNode") -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_set_link(self, arg2)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.TreePreorderIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreePreorderIteratorDepnode_get_node_id(self)

    def set_node_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreePreorderIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreePreorderIteratorDepnode_get_word(self, *args)

    def set_label(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_set_label(self, arg2)

    def set_word(self, arg2: "word") -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_is_head(self)

    def set_head(self, arg2: "bool const") -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreePreorderIteratorDepnode_is_chunk(self)

    def set_chunk(self, arg2: "int const") -> "void":
        return _pyfreeling.TreePreorderIteratorDepnode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreePreorderIteratorDepnode_get_chunk_ord(self)

# Register TreePreorderIteratorDepnode in _pyfreeling:
_pyfreeling.TreePreorderIteratorDepnode_swigregister(TreePreorderIteratorDepnode)

class TreeSiblingIteratorDepnode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeSiblingIteratorDepnode_swiginit(self, _pyfreeling.new_TreeSiblingIteratorDepnode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeSiblingIteratorDepnode

    def incr(self) -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_decr(self)

    def __ref__(self) -> "freeling::depnode &":
        return _pyfreeling.TreeSiblingIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode *":
        return _pyfreeling.TreeSiblingIteratorDepnode___deref__(self)

    def get_info(self) -> "freeling::depnode *":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_info(self)

    def __eq__(self, t: "TreeSiblingIteratorDepnode") -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode___eq__(self, t)

    def __ne__(self, t: "TreeSiblingIteratorDepnode") -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode___ne__(self, t)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_parent(self)

    def nth_child(self, arg2: "unsigned int") -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: "unsigned int") -> "freeling::tree< freeling::depnode > &":
        return _pyfreeling.TreeSiblingIteratorDepnode_nth_child_ref(self, arg2)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_empty(self)

    def has_ancestor(self, p: "TreeOfDepnode") -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeSiblingIteratorDepnode_num_children(self)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeSiblingIteratorDepnode_sibling_rend(self)

    def add_child(self, t: "TreeOfDepnode", last: "bool"=True) -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_hang_child(self, *args)

    def set_link(self, arg2: "TreePreorderIteratorNode") -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_set_link(self, arg2)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_node_id(self)

    def set_node_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_word(self, *args)

    def set_label(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_set_label(self, arg2)

    def set_word(self, arg2: "word") -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_is_head(self)

    def set_head(self, arg2: "bool const") -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreeSiblingIteratorDepnode_is_chunk(self)

    def set_chunk(self, arg2: "int const") -> "void":
        return _pyfreeling.TreeSiblingIteratorDepnode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreeSiblingIteratorDepnode_get_chunk_ord(self)

# Register TreeSiblingIteratorDepnode in _pyfreeling:
_pyfreeling.TreeSiblingIteratorDepnode_swigregister(TreeSiblingIteratorDepnode)

class TreeConstPreorderIteratorNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeConstPreorderIteratorNode_swiginit(self, _pyfreeling.new_TreeConstPreorderIteratorNode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeConstPreorderIteratorNode

    def __ref__(self) -> "freeling::node const &":
        return _pyfreeling.TreeConstPreorderIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node const *":
        return _pyfreeling.TreeConstPreorderIteratorNode___deref__(self)

    def incr(self) -> "void":
        return _pyfreeling.TreeConstPreorderIteratorNode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreeConstPreorderIteratorNode_decr(self)

    def __eq__(self, t: "TreeConstPreorderIteratorNode") -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode___eq__(self, t)

    def __ne__(self, t: "TreeConstPreorderIteratorNode") -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode___ne__(self, t)

    def get_info(self) -> "freeling::node const *":
        return _pyfreeling.TreeConstPreorderIteratorNode_get_info(self)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_empty(self)

    def has_ancestor(self, p: "TreeOfNode") -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeConstPreorderIteratorNode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_get_parent(self)

    def nth_child(self, n: "unsigned int") -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_nth_child(self, n)

    def nth_child_ref(self, n: "unsigned int") -> "freeling::tree< freeling::node > const &":
        return _pyfreeling.TreeConstPreorderIteratorNode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstPreorderIteratorNode_sibling_rend(self)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreeConstPreorderIteratorNode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreeConstPreorderIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreeConstPreorderIteratorNode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_is_head(self)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorNode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreeConstPreorderIteratorNode_get_chunk_ord(self)

# Register TreeConstPreorderIteratorNode in _pyfreeling:
_pyfreeling.TreeConstPreorderIteratorNode_swigregister(TreeConstPreorderIteratorNode)

class TreeConstSiblingIteratorNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeConstSiblingIteratorNode_swiginit(self, _pyfreeling.new_TreeConstSiblingIteratorNode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeConstSiblingIteratorNode

    def __ref__(self) -> "freeling::node const &":
        return _pyfreeling.TreeConstSiblingIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node const *":
        return _pyfreeling.TreeConstSiblingIteratorNode___deref__(self)

    def incr(self) -> "void":
        return _pyfreeling.TreeConstSiblingIteratorNode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreeConstSiblingIteratorNode_decr(self)

    def __eq__(self, t: "TreeConstSiblingIteratorNode") -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode___eq__(self, t)

    def __ne__(self, t: "TreeConstSiblingIteratorNode") -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode___ne__(self, t)

    def get_info(self) -> "freeling::node const *":
        return _pyfreeling.TreeConstSiblingIteratorNode_get_info(self)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_empty(self)

    def has_ancestor(self, p: "TreeOfNode") -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeConstSiblingIteratorNode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_get_parent(self)

    def nth_child(self, n: "unsigned int") -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_nth_child(self, n)

    def nth_child_ref(self, n: "unsigned int") -> "freeling::tree< freeling::node > const &":
        return _pyfreeling.TreeConstSiblingIteratorNode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _pyfreeling.TreeConstSiblingIteratorNode_sibling_rend(self)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreeConstSiblingIteratorNode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreeConstSiblingIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreeConstSiblingIteratorNode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_is_head(self)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorNode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreeConstSiblingIteratorNode_get_chunk_ord(self)

# Register TreeConstSiblingIteratorNode in _pyfreeling:
_pyfreeling.TreeConstSiblingIteratorNode_swigregister(TreeConstSiblingIteratorNode)

class TreeConstPreorderIteratorDepnode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeConstPreorderIteratorDepnode_swiginit(self, _pyfreeling.new_TreeConstPreorderIteratorDepnode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeConstPreorderIteratorDepnode

    def __ref__(self) -> "freeling::depnode const &":
        return _pyfreeling.TreeConstPreorderIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode const *":
        return _pyfreeling.TreeConstPreorderIteratorDepnode___deref__(self)

    def incr(self) -> "void":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_decr(self)

    def __eq__(self, t: "TreeConstPreorderIteratorDepnode") -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode___eq__(self, t)

    def __ne__(self, t: "TreeConstPreorderIteratorDepnode") -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode___ne__(self, t)

    def get_info(self) -> "freeling::depnode const *":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_info(self)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_empty(self)

    def has_ancestor(self, p: "TreeOfDepnode") -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_parent(self)

    def nth_child(self, n: "unsigned int") -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_nth_child(self, n)

    def nth_child_ref(self, n: "unsigned int") -> "freeling::tree< freeling::depnode > const &":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_sibling_rend(self)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_is_head(self)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreeConstPreorderIteratorDepnode_get_chunk_ord(self)

# Register TreeConstPreorderIteratorDepnode in _pyfreeling:
_pyfreeling.TreeConstPreorderIteratorDepnode_swigregister(TreeConstPreorderIteratorDepnode)

class TreeConstSiblingIteratorDepnode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.TreeConstSiblingIteratorDepnode_swiginit(self, _pyfreeling.new_TreeConstSiblingIteratorDepnode(*args))
    __swig_destroy__ = _pyfreeling.delete_TreeConstSiblingIteratorDepnode

    def __ref__(self) -> "freeling::depnode const &":
        return _pyfreeling.TreeConstSiblingIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode const *":
        return _pyfreeling.TreeConstSiblingIteratorDepnode___deref__(self)

    def incr(self) -> "void":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_decr(self)

    def __eq__(self, t: "TreeConstSiblingIteratorDepnode") -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode___eq__(self, t)

    def __ne__(self, t: "TreeConstSiblingIteratorDepnode") -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode___ne__(self, t)

    def get_info(self) -> "freeling::depnode const *":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_info(self)

    def is_defined(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_empty(self)

    def has_ancestor(self, p: "TreeOfDepnode") -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_parent(self)

    def nth_child(self, n: "unsigned int") -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_nth_child(self, n)

    def nth_child_ref(self, n: "unsigned int") -> "freeling::tree< freeling::depnode > const &":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_sibling_rend(self)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_is_head(self)

    def is_chunk(self) -> "bool":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.TreeConstSiblingIteratorDepnode_get_chunk_ord(self)

# Register TreeConstSiblingIteratorDepnode in _pyfreeling:
_pyfreeling.TreeConstSiblingIteratorDepnode_swigregister(TreeConstSiblingIteratorDepnode)

class analysis(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_pyfreeling.analysis_user_get, _pyfreeling.analysis_user_set)

    def __init__(self, *args):
        _pyfreeling.analysis_swiginit(self, _pyfreeling.new_analysis(*args))
    __swig_destroy__ = _pyfreeling.delete_analysis

    def init(self, l: "std::wstring const &", t: "std::wstring const &") -> "void":
        return _pyfreeling.analysis_init(self, l, t)

    def set_lemma(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.analysis_set_lemma(self, arg2)

    def set_tag(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.analysis_set_tag(self, arg2)

    def set_prob(self, arg2: "double") -> "void":
        return _pyfreeling.analysis_set_prob(self, arg2)

    def set_distance(self, arg2: "double") -> "void":
        return _pyfreeling.analysis_set_distance(self, arg2)

    def set_retokenizable(self, arg2: "ListWord") -> "void":
        return _pyfreeling.analysis_set_retokenizable(self, arg2)

    def has_prob(self) -> "bool":
        return _pyfreeling.analysis_has_prob(self)

    def has_distance(self) -> "bool":
        return _pyfreeling.analysis_has_distance(self)

    def get_lemma(self) -> "std::wstring":
        return _pyfreeling.analysis_get_lemma(self)

    def get_tag(self) -> "std::wstring":
        return _pyfreeling.analysis_get_tag(self)

    def get_prob(self) -> "double":
        return _pyfreeling.analysis_get_prob(self)

    def get_distance(self) -> "double":
        return _pyfreeling.analysis_get_distance(self)

    def is_retokenizable(self) -> "bool":
        return _pyfreeling.analysis_is_retokenizable(self)

    def get_retokenizable(self) -> "std::list< freeling::word,std::allocator< freeling::word > >":
        return _pyfreeling.analysis_get_retokenizable(self)

    def get_senses(self) -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > >":
        return _pyfreeling.analysis_get_senses(self)

    def set_senses(self, arg2: "ListPairStringDouble") -> "void":
        return _pyfreeling.analysis_set_senses(self, arg2)

    def get_senses_string(self) -> "std::wstring":
        return _pyfreeling.analysis_get_senses_string(self)

    def __gt__(self, arg2: "analysis") -> "bool":
        return _pyfreeling.analysis___gt__(self, arg2)

    def __lt__(self, arg2: "analysis") -> "bool":
        return _pyfreeling.analysis___lt__(self, arg2)

    def __eq__(self, arg2: "analysis") -> "bool":
        return _pyfreeling.analysis___eq__(self, arg2)

    def is_selected(self, k: "int"=0) -> "bool":
        return _pyfreeling.analysis_is_selected(self, k)

    def mark_selected(self, k: "int"=0) -> "void":
        return _pyfreeling.analysis_mark_selected(self, k)

    def unmark_selected(self, k: "int"=0) -> "void":
        return _pyfreeling.analysis_unmark_selected(self, k)

# Register analysis in _pyfreeling:
_pyfreeling.analysis_swigregister(analysis)

class alternative(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.alternative_swiginit(self, _pyfreeling.new_alternative(*args))

    def __eq__(self, arg2: "alternative") -> "bool":
        return _pyfreeling.alternative___eq__(self, arg2)

    def get_form(self) -> "std::wstring":
        return _pyfreeling.alternative_get_form(self)

    def get_distance(self) -> "int":
        return _pyfreeling.alternative_get_distance(self)

    def get_probability(self) -> "float":
        return _pyfreeling.alternative_get_probability(self)

    def is_selected(self, k: "int"=1) -> "bool":
        return _pyfreeling.alternative_is_selected(self, k)

    def clear_selections(self) -> "void":
        return _pyfreeling.alternative_clear_selections(self)

    def add_selection(self, arg2: "int") -> "void":
        return _pyfreeling.alternative_add_selection(self, arg2)

    def set_form(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.alternative_set_form(self, arg2)

    def set_distance(self, arg2: "int") -> "void":
        return _pyfreeling.alternative_set_distance(self, arg2)

    def set_probability(self, arg2: "float") -> "void":
        return _pyfreeling.alternative_set_probability(self, arg2)
    __swig_destroy__ = _pyfreeling.delete_alternative

# Register alternative in _pyfreeling:
_pyfreeling.alternative_swigregister(alternative)

class word(ListAnalysis):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    USERMAP = _pyfreeling.word_USERMAP
    NUMBERS = _pyfreeling.word_NUMBERS
    PUNCTUATION = _pyfreeling.word_PUNCTUATION
    DATES = _pyfreeling.word_DATES
    DICTIONARY = _pyfreeling.word_DICTIONARY
    AFFIXES = _pyfreeling.word_AFFIXES
    COMPOUNDS = _pyfreeling.word_COMPOUNDS
    MULTIWORDS = _pyfreeling.word_MULTIWORDS
    NER = _pyfreeling.word_NER
    QUANTITIES = _pyfreeling.word_QUANTITIES
    PROBABILITIES = _pyfreeling.word_PROBABILITIES
    GUESSER = _pyfreeling.word_GUESSER
    user = property(_pyfreeling.word_user_get, _pyfreeling.word_user_set)

    def __init__(self, *args):
        _pyfreeling.word_swiginit(self, _pyfreeling.new_word(*args))
    __swig_destroy__ = _pyfreeling.delete_word

    def copy_analysis(self, arg2: "word") -> "void":
        return _pyfreeling.word_copy_analysis(self, arg2)

    def get_n_selected(self) -> "int":
        return _pyfreeling.word_get_n_selected(self)

    def get_n_unselected(self) -> "int":
        return _pyfreeling.word_get_n_unselected(self)

    def is_multiword(self) -> "bool":
        return _pyfreeling.word_is_multiword(self)

    def is_ambiguous_mw(self) -> "bool":
        return _pyfreeling.word_is_ambiguous_mw(self)

    def set_ambiguous_mw(self, arg2: "bool") -> "void":
        return _pyfreeling.word_set_ambiguous_mw(self, arg2)

    def get_n_words_mw(self) -> "int":
        return _pyfreeling.word_get_n_words_mw(self)

    def get_words_mw(self) -> "std::list< freeling::word,std::allocator< freeling::word > > const &":
        return _pyfreeling.word_get_words_mw(self)

    def get_form(self) -> "std::wstring":
        return _pyfreeling.word_get_form(self)

    def get_lc_form(self) -> "std::wstring":
        return _pyfreeling.word_get_lc_form(self)

    def get_ph_form(self) -> "std::wstring":
        return _pyfreeling.word_get_ph_form(self)

    def selected_begin(self, *args) -> "freeling::word::const_iterator":
        return _pyfreeling.word_selected_begin(self, *args)

    def selected_end(self, *args) -> "freeling::word::const_iterator":
        return _pyfreeling.word_selected_end(self, *args)

    def unselected_begin(self, *args) -> "freeling::word::const_iterator":
        return _pyfreeling.word_unselected_begin(self, *args)

    def unselected_end(self, *args) -> "freeling::word::const_iterator":
        return _pyfreeling.word_unselected_end(self, *args)

    def num_kbest(self) -> "unsigned int":
        return _pyfreeling.word_num_kbest(self)

    def get_lemma(self, k: "int"=0) -> "std::wstring":
        return _pyfreeling.word_get_lemma(self, k)

    def get_tag(self, k: "int"=0) -> "std::wstring":
        return _pyfreeling.word_get_tag(self, k)

    def get_senses(self, k: "int"=0) -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > >":
        return _pyfreeling.word_get_senses(self, k)

    def get_senses_string(self, k: "int"=0) -> "std::wstring":
        return _pyfreeling.word_get_senses_string(self, k)

    def set_senses(self, arg2: "ListPairStringDouble", k: "int"=0) -> "void":
        return _pyfreeling.word_set_senses(self, arg2, k)

    def get_span_start(self) -> "unsigned long":
        return _pyfreeling.word_get_span_start(self)

    def get_span_finish(self) -> "unsigned long":
        return _pyfreeling.word_get_span_finish(self)

    def has_retokenizable(self) -> "bool":
        return _pyfreeling.word_has_retokenizable(self)

    def lock_analysis(self) -> "void":
        return _pyfreeling.word_lock_analysis(self)

    def unlock_analysis(self) -> "void":
        return _pyfreeling.word_unlock_analysis(self)

    def is_locked_analysis(self) -> "bool":
        return _pyfreeling.word_is_locked_analysis(self)

    def lock_multiwords(self) -> "void":
        return _pyfreeling.word_lock_multiwords(self)

    def unlock_multiwords(self) -> "void":
        return _pyfreeling.word_unlock_multiwords(self)

    def is_locked_multiwords(self) -> "bool":
        return _pyfreeling.word_is_locked_multiwords(self)

    def set_analyzed_by(self, arg2: "unsigned int") -> "void":
        return _pyfreeling.word_set_analyzed_by(self, arg2)

    def is_analyzed_by(self, arg2: "unsigned int") -> "bool":
        return _pyfreeling.word_is_analyzed_by(self, arg2)

    def get_analyzed_by(self) -> "unsigned int":
        return _pyfreeling.word_get_analyzed_by(self)

    def add_alternative(self, *args) -> "void":
        return _pyfreeling.word_add_alternative(self, *args)

    def set_alternatives(self, arg2: "std::list< std::pair< std::wstring,int >,std::allocator< std::pair< std::wstring,int > > > const &") -> "void":
        return _pyfreeling.word_set_alternatives(self, arg2)

    def clear_alternatives(self) -> "void":
        return _pyfreeling.word_clear_alternatives(self)

    def has_alternatives(self) -> "bool":
        return _pyfreeling.word_has_alternatives(self)

    def get_alternatives(self, *args) -> "std::list< freeling::alternative,std::allocator< freeling::alternative > > const &":
        return _pyfreeling.word_get_alternatives(self, *args)

    def alternatives_begin(self, *args) -> "std::list< freeling::alternative,std::allocator< freeling::alternative > >::const_iterator":
        return _pyfreeling.word_alternatives_begin(self, *args)

    def alternatives_end(self, *args) -> "std::list< freeling::alternative,std::allocator< freeling::alternative > >::const_iterator":
        return _pyfreeling.word_alternatives_end(self, *args)

    def add_analysis(self, arg2: "analysis") -> "void":
        return _pyfreeling.word_add_analysis(self, arg2)

    def set_analysis(self, *args) -> "void":
        return _pyfreeling.word_set_analysis(self, *args)

    def set_form(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.word_set_form(self, arg2)

    def set_ph_form(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.word_set_ph_form(self, arg2)

    def set_span(self, arg2: "unsigned long", arg3: "unsigned long") -> "void":
        return _pyfreeling.word_set_span(self, arg2, arg3)

    def set_position(self, arg2: "size_t") -> "void":
        return _pyfreeling.word_set_position(self, arg2)

    def get_position(self) -> "size_t":
        return _pyfreeling.word_get_position(self)

    def find_tag_match(self, arg2: "freeling::regexp &") -> "bool":
        return _pyfreeling.word_find_tag_match(self, arg2)

    def get_n_analysis(self) -> "int":
        return _pyfreeling.word_get_n_analysis(self)

    def unselect_all_analysis(self, k: "int"=0) -> "void":
        return _pyfreeling.word_unselect_all_analysis(self, k)

    def select_all_analysis(self, k: "int"=0) -> "void":
        return _pyfreeling.word_select_all_analysis(self, k)

    def select_analysis(self, arg2: "freeling::word::iterator", k: "int"=0) -> "void":
        return _pyfreeling.word_select_analysis(self, arg2, k)

    def unselect_analysis(self, arg2: "freeling::word::iterator", k: "int"=0) -> "void":
        return _pyfreeling.word_unselect_analysis(self, arg2, k)

    def get_analysis(self) -> "std::list< freeling::analysis,std::allocator< freeling::analysis > >":
        return _pyfreeling.word_get_analysis(self)

    def analysis_begin(self, *args) -> "freeling::word::const_iterator":
        return _pyfreeling.word_analysis_begin(self, *args)

    def analysis_end(self, *args) -> "freeling::word::const_iterator":
        return _pyfreeling.word_analysis_end(self, *args)

# Register word in _pyfreeling:
_pyfreeling.word_swigregister(word)

class node(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.node_swiginit(self, _pyfreeling.new_node(*args))
    __swig_destroy__ = _pyfreeling.delete_node

    def get_node_id(self) -> "std::wstring":
        return _pyfreeling.node_get_node_id(self)

    def set_node_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.node_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _pyfreeling.node_get_label(self)

    def has_word(self) -> "bool":
        return _pyfreeling.node_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _pyfreeling.node_get_word(self, *args)

    def set_label(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.node_set_label(self, arg2)

    def set_word(self, arg2: "word") -> "void":
        return _pyfreeling.node_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _pyfreeling.node_is_head(self)

    def set_head(self, arg2: "bool const") -> "void":
        return _pyfreeling.node_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _pyfreeling.node_is_chunk(self)

    def set_chunk(self, arg2: "int const") -> "void":
        return _pyfreeling.node_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _pyfreeling.node_get_chunk_ord(self)

# Register node in _pyfreeling:
_pyfreeling.node_swigregister(node)

class parse_tree(TreeOfNode):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.parse_tree_swiginit(self, _pyfreeling.new_parse_tree(*args))

    def build_node_index(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.parse_tree_build_node_index(self, arg2)

    def rebuild_node_index(self) -> "void":
        return _pyfreeling.parse_tree_rebuild_node_index(self)

    def get_node_by_id(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.parse_tree_get_node_by_id(self, *args)

    def get_node_by_pos(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.parse_tree_get_node_by_pos(self, *args)

    @staticmethod
    def get_head_word(arg1: "TreeConstPreorderIteratorNode") -> "freeling::word const &":
        return _pyfreeling.parse_tree_get_head_word(arg1)

    @staticmethod
    def get_head_position(pt: "TreeConstPreorderIteratorNode") -> "int":
        return _pyfreeling.parse_tree_get_head_position(pt)

    @staticmethod
    def C_commands(arg1: "TreeConstPreorderIteratorNode", arg2: "TreeConstPreorderIteratorNode") -> "bool":
        return _pyfreeling.parse_tree_C_commands(arg1, arg2)

    def nth_child_ref(self, arg2: "unsigned int") -> "freeling::parse_tree &":
        return _pyfreeling.parse_tree_nth_child_ref(self, arg2)
    __swig_destroy__ = _pyfreeling.delete_parse_tree

# Register parse_tree in _pyfreeling:
_pyfreeling.parse_tree_swigregister(parse_tree)

def parse_tree_get_head_word(arg1: "TreeConstPreorderIteratorNode") -> "freeling::word const &":
    return _pyfreeling.parse_tree_get_head_word(arg1)

def parse_tree_get_head_position(pt: "TreeConstPreorderIteratorNode") -> "int":
    return _pyfreeling.parse_tree_get_head_position(pt)

def parse_tree_C_commands(arg1: "TreeConstPreorderIteratorNode", arg2: "TreeConstPreorderIteratorNode") -> "bool":
    return _pyfreeling.parse_tree_C_commands(arg1, arg2)

class depnode(node):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.depnode_swiginit(self, _pyfreeling.new_depnode(*args))
    __swig_destroy__ = _pyfreeling.delete_depnode

    def set_link(self, arg2: "TreePreorderIteratorNode") -> "void":
        return _pyfreeling.depnode_set_link(self, arg2)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.depnode_get_link(self, *args)

# Register depnode in _pyfreeling:
_pyfreeling.depnode_swigregister(depnode)

class dep_tree(TreeOfDepnode):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.dep_tree_swiginit(self, _pyfreeling.new_dep_tree(*args))

    def get_node_by_pos(self, *args) -> "freeling::dep_tree::const_iterator":
        return _pyfreeling.dep_tree_get_node_by_pos(self, *args)

    def rebuild_node_index(self) -> "void":
        return _pyfreeling.dep_tree_rebuild_node_index(self)

    @staticmethod
    def get_first_word(arg1: "TreeConstPreorderIteratorDepnode") -> "size_t":
        return _pyfreeling.dep_tree_get_first_word(arg1)

    @staticmethod
    def get_last_word(arg1: "TreeConstPreorderIteratorDepnode") -> "size_t":
        return _pyfreeling.dep_tree_get_last_word(arg1)

    def nth_child_ref(self, arg2: "unsigned int") -> "freeling::dep_tree &":
        return _pyfreeling.dep_tree_nth_child_ref(self, arg2)
    __swig_destroy__ = _pyfreeling.delete_dep_tree

# Register dep_tree in _pyfreeling:
_pyfreeling.dep_tree_swigregister(dep_tree)

def dep_tree_get_first_word(arg1: "TreeConstPreorderIteratorDepnode") -> "size_t":
    return _pyfreeling.dep_tree_get_first_word(arg1)

def dep_tree_get_last_word(arg1: "TreeConstPreorderIteratorDepnode") -> "size_t":
    return _pyfreeling.dep_tree_get_last_word(arg1)

class argument(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyfreeling.delete_argument

    def __init__(self, *args):
        _pyfreeling.argument_swiginit(self, _pyfreeling.new_argument(*args))

    def get_position(self) -> "int":
        return _pyfreeling.argument_get_position(self)

    def get_role(self) -> "std::wstring":
        return _pyfreeling.argument_get_role(self)

# Register argument in _pyfreeling:
_pyfreeling.argument_swigregister(argument)
cvar = _pyfreeling.cvar
argument.EMPTY_ROLE = _pyfreeling.cvar.argument_EMPTY_ROLE

class predicate(VectorArgument):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyfreeling.delete_predicate

    def __init__(self, *args):
        _pyfreeling.predicate_swiginit(self, _pyfreeling.new_predicate(*args))

    def get_sense(self) -> "std::wstring":
        return _pyfreeling.predicate_get_sense(self)

    def get_position(self) -> "int":
        return _pyfreeling.predicate_get_position(self)

    def has_argument(self, p: "int") -> "bool":
        return _pyfreeling.predicate_has_argument(self, p)

    def add_argument(self, p: "int", r: "std::wstring const &") -> "void":
        return _pyfreeling.predicate_add_argument(self, p, r)

    def get_argument_by_pos(self, p: "int") -> "freeling::argument const &":
        return _pyfreeling.predicate_get_argument_by_pos(self, p)

# Register predicate in _pyfreeling:
_pyfreeling.predicate_swigregister(predicate)

class sentence(ListWord):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.sentence_swiginit(self, _pyfreeling.new_sentence(*args))
    __swig_destroy__ = _pyfreeling.delete_sentence

    def num_kbest(self) -> "unsigned int":
        return _pyfreeling.sentence_num_kbest(self)

    def push_back(self, arg2: "word") -> "void":
        return _pyfreeling.sentence_push_back(self, arg2)

    def rebuild_word_index(self) -> "void":
        return _pyfreeling.sentence_rebuild_word_index(self)

    def clear(self) -> "void":
        return _pyfreeling.sentence_clear(self)

    def set_sentence_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.sentence_set_sentence_id(self, arg2)

    def get_sentence_id(self) -> "std::wstring":
        return _pyfreeling.sentence_get_sentence_id(self)

    def set_is_tagged(self, arg2: "bool") -> "void":
        return _pyfreeling.sentence_set_is_tagged(self, arg2)

    def is_tagged(self) -> "bool":
        return _pyfreeling.sentence_is_tagged(self)

    def set_best_seq(self, k: "int") -> "void":
        return _pyfreeling.sentence_set_best_seq(self, k)

    def get_best_seq(self) -> "int":
        return _pyfreeling.sentence_get_best_seq(self)

    def set_parse_tree(self, arg2: "parse_tree", k: "int"=0) -> "void":
        return _pyfreeling.sentence_set_parse_tree(self, arg2, k)

    def get_parse_tree(self, *args) -> "freeling::parse_tree const &":
        return _pyfreeling.sentence_get_parse_tree(self, *args)

    def is_parsed(self) -> "bool":
        return _pyfreeling.sentence_is_parsed(self)

    def set_dep_tree(self, arg2: "dep_tree", k: "int"=0) -> "void":
        return _pyfreeling.sentence_set_dep_tree(self, arg2, k)

    def get_dep_tree(self, *args) -> "freeling::dep_tree const &":
        return _pyfreeling.sentence_get_dep_tree(self, *args)

    def is_dep_parsed(self) -> "bool":
        return _pyfreeling.sentence_is_dep_parsed(self)

    def get_words(self) -> "std::vector< freeling::word,std::allocator< freeling::word > >":
        return _pyfreeling.sentence_get_words(self)

    def words_begin(self, *args) -> "freeling::sentence::const_iterator":
        return _pyfreeling.sentence_words_begin(self, *args)

    def words_end(self, *args) -> "freeling::sentence::const_iterator":
        return _pyfreeling.sentence_words_end(self, *args)

    def get_word_iterator(self, *args) -> "freeling::sentence::iterator":
        return _pyfreeling.sentence_get_word_iterator(self, *args)

    def add_predicate(self, pr: "predicate") -> "void":
        return _pyfreeling.sentence_add_predicate(self, pr)

    def is_predicate(self, p: "int") -> "bool":
        return _pyfreeling.sentence_is_predicate(self, p)

    def get_predicate_number(self, p: "int") -> "int":
        return _pyfreeling.sentence_get_predicate_number(self, p)

    def get_predicate_position(self, n: "int") -> "int":
        return _pyfreeling.sentence_get_predicate_position(self, n)

    def get_predicate_by_pos(self, n: "int") -> "freeling::predicate const &":
        return _pyfreeling.sentence_get_predicate_by_pos(self, n)

    def get_predicate_by_number(self, n: "int") -> "freeling::predicate const &":
        return _pyfreeling.sentence_get_predicate_by_number(self, n)

    def get_predicates(self) -> "freeling::sentence::predicates const &":
        return _pyfreeling.sentence_get_predicates(self)

# Register sentence in _pyfreeling:
_pyfreeling.sentence_swigregister(sentence)

class paragraph(ListSentence):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.paragraph_swiginit(self, _pyfreeling.new_paragraph(*args))

    def set_paragraph_id(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.paragraph_set_paragraph_id(self, arg2)

    def get_paragraph_id(self) -> "std::wstring":
        return _pyfreeling.paragraph_get_paragraph_id(self)
    __swig_destroy__ = _pyfreeling.delete_paragraph

# Register paragraph in _pyfreeling:
_pyfreeling.paragraph_swigregister(paragraph)

class mention(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PROPER_NOUN = _pyfreeling.mention_PROPER_NOUN
    PRONOUN = _pyfreeling.mention_PRONOUN
    NOUN_PHRASE = _pyfreeling.mention_NOUN_PHRASE
    COMPOSITE = _pyfreeling.mention_COMPOSITE
    VERB_PHRASE = _pyfreeling.mention_VERB_PHRASE
    PER = _pyfreeling.mention_PER
    MALE = _pyfreeling.mention_MALE
    FEMALE = _pyfreeling.mention_FEMALE
    NOTPER = _pyfreeling.mention_NOTPER
    ORG = _pyfreeling.mention_ORG
    GEO = _pyfreeling.mention_GEO
    OTHER = _pyfreeling.mention_OTHER

    def __init__(self, *args):
        _pyfreeling.mention_swiginit(self, _pyfreeling.new_mention(*args))

    def __lt__(self, m: "mention") -> "bool":
        return _pyfreeling.mention___lt__(self, m)

    def set_id(self, arg2: "int") -> "void":
        return _pyfreeling.mention_set_id(self, arg2)

    def set_type(self, arg2: "freeling::mention::mentionType") -> "void":
        return _pyfreeling.mention_set_type(self, arg2)

    def set_initial(self, arg2: "bool") -> "void":
        return _pyfreeling.mention_set_initial(self, arg2)

    def set_group(self, arg2: "int") -> "void":
        return _pyfreeling.mention_set_group(self, arg2)

    def set_maximal(self, b: "bool") -> "void":
        return _pyfreeling.mention_set_maximal(self, b)

    def get_id(self) -> "int":
        return _pyfreeling.mention_get_id(self)

    def get_n_sentence(self) -> "int":
        return _pyfreeling.mention_get_n_sentence(self)

    def get_sentence(self) -> "freeling::paragraph::const_iterator":
        return _pyfreeling.mention_get_sentence(self)

    def get_pos_begin(self) -> "int":
        return _pyfreeling.mention_get_pos_begin(self)

    def get_pos_end(self) -> "int":
        return _pyfreeling.mention_get_pos_end(self)

    def get_it_begin(self) -> "freeling::sentence::const_iterator":
        return _pyfreeling.mention_get_it_begin(self)

    def get_it_end(self) -> "freeling::sentence::const_iterator":
        return _pyfreeling.mention_get_it_end(self)

    def get_it_head(self) -> "freeling::sentence::const_iterator":
        return _pyfreeling.mention_get_it_head(self)

    def get_type(self) -> "freeling::mention::mentionType":
        return _pyfreeling.mention_get_type(self)

    def get_group(self) -> "int":
        return _pyfreeling.mention_get_group(self)

    def is_type(self, arg2: "freeling::mention::mentionType") -> "bool":
        return _pyfreeling.mention_is_type(self, arg2)

    def is_initial(self) -> "bool":
        return _pyfreeling.mention_is_initial(self)

    def is_maximal(self) -> "bool":
        return _pyfreeling.mention_is_maximal(self)

    def get_ptree(self) -> "freeling::parse_tree::const_iterator":
        return _pyfreeling.mention_get_ptree(self)

    def get_head(self) -> "freeling::word const &":
        return _pyfreeling.mention_get_head(self)

    def value(self) -> "std::wstring":
        return _pyfreeling.mention_value(self)
    __swig_destroy__ = _pyfreeling.delete_mention

# Register mention in _pyfreeling:
_pyfreeling.mention_swigregister(mention)

class SG_mention(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mid: "std::wstring const &", sid: "std::wstring const &", wds: "ListString"):
        _pyfreeling.SG_mention_swiginit(self, _pyfreeling.new_SG_mention(mid, sid, wds))
    __swig_destroy__ = _pyfreeling.delete_SG_mention

    def get_id(self) -> "std::wstring":
        return _pyfreeling.SG_mention_get_id(self)

    def get_sentence_id(self) -> "std::wstring":
        return _pyfreeling.SG_mention_get_sentence_id(self)

    def get_words(self) -> "std::list< std::wstring,std::allocator< std::wstring > > const &":
        return _pyfreeling.SG_mention_get_words(self)

# Register SG_mention in _pyfreeling:
_pyfreeling.SG_mention_swigregister(SG_mention)

ENTITY = _pyfreeling.ENTITY
WORD = _pyfreeling.WORD
class SG_entity(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, elemma: "std::wstring const &", eclass: "std::wstring const &", type: "freeling::semgraph::entityType", sense: "std::wstring const &"):
        _pyfreeling.SG_entity_swiginit(self, _pyfreeling.new_SG_entity(elemma, eclass, type, sense))
    __swig_destroy__ = _pyfreeling.delete_SG_entity

    def set_lemma(self, lem: "std::wstring const &") -> "void":
        return _pyfreeling.SG_entity_set_lemma(self, lem)

    def get_id(self) -> "std::wstring":
        return _pyfreeling.SG_entity_get_id(self)

    def get_lemma(self) -> "std::wstring":
        return _pyfreeling.SG_entity_get_lemma(self)

    def get_semclass(self) -> "std::wstring":
        return _pyfreeling.SG_entity_get_semclass(self)

    def get_type(self) -> "freeling::semgraph::entityType":
        return _pyfreeling.SG_entity_get_type(self)

    def get_sense(self) -> "std::wstring":
        return _pyfreeling.SG_entity_get_sense(self)

    def get_mentions(self) -> "std::vector< freeling::semgraph::SG_mention,std::allocator< freeling::semgraph::SG_mention > > const &":
        return _pyfreeling.SG_entity_get_mentions(self)

# Register SG_entity in _pyfreeling:
_pyfreeling.SG_entity_swigregister(SG_entity)

class SG_argument(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "std::wstring const &", e: "std::wstring const &"):
        _pyfreeling.SG_argument_swiginit(self, _pyfreeling.new_SG_argument(r, e))
    __swig_destroy__ = _pyfreeling.delete_SG_argument

    def get_role(self) -> "std::wstring":
        return _pyfreeling.SG_argument_get_role(self)

    def get_entity(self) -> "std::wstring":
        return _pyfreeling.SG_argument_get_entity(self)

# Register SG_argument in _pyfreeling:
_pyfreeling.SG_argument_swigregister(SG_argument)

class SG_frame(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lem: "std::wstring const &", sns: "std::wstring const &", tk: "std::wstring const &", sid: "std::wstring const &"):
        _pyfreeling.SG_frame_swiginit(self, _pyfreeling.new_SG_frame(lem, sns, tk, sid))
    __swig_destroy__ = _pyfreeling.delete_SG_frame

    def get_id(self) -> "std::wstring":
        return _pyfreeling.SG_frame_get_id(self)

    def get_lemma(self) -> "std::wstring":
        return _pyfreeling.SG_frame_get_lemma(self)

    def get_sense(self) -> "std::wstring":
        return _pyfreeling.SG_frame_get_sense(self)

    def get_token_id(self) -> "std::wstring":
        return _pyfreeling.SG_frame_get_token_id(self)

    def get_sentence_id(self) -> "std::wstring":
        return _pyfreeling.SG_frame_get_sentence_id(self)

    def get_arguments(self) -> "std::vector< freeling::semgraph::SG_argument,std::allocator< freeling::semgraph::SG_argument > > const &":
        return _pyfreeling.SG_frame_get_arguments(self)

# Register SG_frame in _pyfreeling:
_pyfreeling.SG_frame_swigregister(SG_frame)

class semantic_graph(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyfreeling.semantic_graph_swiginit(self, _pyfreeling.new_semantic_graph())
    __swig_destroy__ = _pyfreeling.delete_semantic_graph

    def add_entity(self, ent: "SG_entity") -> "std::wstring":
        return _pyfreeling.semantic_graph_add_entity(self, ent)

    def add_frame(self, fr: "SG_frame") -> "std::wstring":
        return _pyfreeling.semantic_graph_add_frame(self, fr)

    def get_frame(self, *args) -> "freeling::semgraph::SG_frame &":
        return _pyfreeling.semantic_graph_get_frame(self, *args)

    def get_entity_id_by_mention(self, sid: "std::wstring const &", wid: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.semantic_graph_get_entity_id_by_mention(self, sid, wid)

    def get_entity_id_by_lemma(self, lemma: "std::wstring const &", sens: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.semantic_graph_get_entity_id_by_lemma(self, lemma, sens)

    def get_entity(self, *args) -> "freeling::semgraph::SG_entity &":
        return _pyfreeling.semantic_graph_get_entity(self, *args)

    def get_entities(self, *args) -> "std::vector< freeling::semgraph::SG_entity,std::allocator< freeling::semgraph::SG_entity > > &":
        return _pyfreeling.semantic_graph_get_entities(self, *args)

    def get_frames(self, *args) -> "std::vector< freeling::semgraph::SG_frame,std::allocator< freeling::semgraph::SG_frame > > &":
        return _pyfreeling.semantic_graph_get_frames(self, *args)

    def add_mention_to_entity(self, eid: "std::wstring const &", m: "SG_mention") -> "void":
        return _pyfreeling.semantic_graph_add_mention_to_entity(self, eid, m)

    def add_argument_to_frame(self, fid: "std::wstring const &", role: "std::wstring const &", eid: "std::wstring const &") -> "void":
        return _pyfreeling.semantic_graph_add_argument_to_frame(self, fid, role, eid)

    def is_argument(self, eid: "std::wstring const &") -> "bool":
        return _pyfreeling.semantic_graph_is_argument(self, eid)

    def has_arguments(self, fid: "std::wstring const &") -> "bool":
        return _pyfreeling.semantic_graph_has_arguments(self, fid)

    def empty(self) -> "bool":
        return _pyfreeling.semantic_graph_empty(self)

# Register semantic_graph in _pyfreeling:
_pyfreeling.semantic_graph_swigregister(semantic_graph)

class document(ListParagraph):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.document_swiginit(self, _pyfreeling.new_document(*args))

    def is_parsed(self) -> "bool":
        return _pyfreeling.document_is_parsed(self)

    def is_dep_parsed(self) -> "bool":
        return _pyfreeling.document_is_dep_parsed(self)

    def add_mention(self, m: "mention") -> "void":
        return _pyfreeling.document_add_mention(self, m)

    def get_num_words(self) -> "int":
        return _pyfreeling.document_get_num_words(self)

    def get_num_groups(self) -> "int":
        return _pyfreeling.document_get_num_groups(self)

    def get_groups(self) -> "std::list< int,std::allocator< int > > const &":
        return _pyfreeling.document_get_groups(self)

    def begin_mentions(self, *args) -> "std::vector< freeling::mention,std::allocator< freeling::mention > >::const_iterator":
        return _pyfreeling.document_begin_mentions(self, *args)

    def end_mentions(self, *args) -> "std::vector< freeling::mention,std::allocator< freeling::mention > >::const_iterator":
        return _pyfreeling.document_end_mentions(self, *args)

    def get_semantic_graph(self, *args) -> "freeling::semgraph::semantic_graph &":
        return _pyfreeling.document_get_semantic_graph(self, *args)

    def get_mention(self, arg2: "int") -> "freeling::mention const &":
        return _pyfreeling.document_get_mention(self, arg2)

    def get_coref_id_mentions(self, arg2: "int") -> "std::list< int,std::allocator< int > >":
        return _pyfreeling.document_get_coref_id_mentions(self, arg2)
    __swig_destroy__ = _pyfreeling.delete_document

# Register document in _pyfreeling:
_pyfreeling.document_swigregister(document)

TEXT = _pyfreeling.TEXT
IDENT = _pyfreeling.IDENT
TOKEN = _pyfreeling.TOKEN
SPLITTED = _pyfreeling.SPLITTED
MORFO = _pyfreeling.MORFO
TAGGED = _pyfreeling.TAGGED
SENSES = _pyfreeling.SENSES
SHALLOW = _pyfreeling.SHALLOW
PARSED = _pyfreeling.PARSED
DEP = _pyfreeling.DEP
COREF = _pyfreeling.COREF
SEMGRAPH = _pyfreeling.SEMGRAPH
NO_TAGGER = _pyfreeling.NO_TAGGER
HMM = _pyfreeling.HMM
RELAX = _pyfreeling.RELAX
NO_DEP = _pyfreeling.NO_DEP
TXALA = _pyfreeling.TXALA
TREELER = _pyfreeling.TREELER
NO_WSD = _pyfreeling.NO_WSD
ALL = _pyfreeling.ALL
MFS = _pyfreeling.MFS
UKB = _pyfreeling.UKB
NO_FORCE = _pyfreeling.NO_FORCE
TAGGER = _pyfreeling.TAGGER
RETOK = _pyfreeling.RETOK
class config_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Lang = property(_pyfreeling.config_options_Lang_get, _pyfreeling.config_options_Lang_set)
    TOK_TokenizerFile = property(_pyfreeling.config_options_TOK_TokenizerFile_get, _pyfreeling.config_options_TOK_TokenizerFile_set)
    SPLIT_SplitterFile = property(_pyfreeling.config_options_SPLIT_SplitterFile_get, _pyfreeling.config_options_SPLIT_SplitterFile_set)
    MACO_Decimal = property(_pyfreeling.config_options_MACO_Decimal_get, _pyfreeling.config_options_MACO_Decimal_set)
    MACO_Thousand = property(_pyfreeling.config_options_MACO_Thousand_get, _pyfreeling.config_options_MACO_Thousand_set)
    MACO_UserMapFile = property(_pyfreeling.config_options_MACO_UserMapFile_get, _pyfreeling.config_options_MACO_UserMapFile_set)
    MACO_LocutionsFile = property(_pyfreeling.config_options_MACO_LocutionsFile_get, _pyfreeling.config_options_MACO_LocutionsFile_set)
    MACO_QuantitiesFile = property(_pyfreeling.config_options_MACO_QuantitiesFile_get, _pyfreeling.config_options_MACO_QuantitiesFile_set)
    MACO_AffixFile = property(_pyfreeling.config_options_MACO_AffixFile_get, _pyfreeling.config_options_MACO_AffixFile_set)
    MACO_ProbabilityFile = property(_pyfreeling.config_options_MACO_ProbabilityFile_get, _pyfreeling.config_options_MACO_ProbabilityFile_set)
    MACO_DictionaryFile = property(_pyfreeling.config_options_MACO_DictionaryFile_get, _pyfreeling.config_options_MACO_DictionaryFile_set)
    MACO_NPDataFile = property(_pyfreeling.config_options_MACO_NPDataFile_get, _pyfreeling.config_options_MACO_NPDataFile_set)
    MACO_PunctuationFile = property(_pyfreeling.config_options_MACO_PunctuationFile_get, _pyfreeling.config_options_MACO_PunctuationFile_set)
    MACO_CompoundFile = property(_pyfreeling.config_options_MACO_CompoundFile_get, _pyfreeling.config_options_MACO_CompoundFile_set)
    MACO_ProbabilityThreshold = property(_pyfreeling.config_options_MACO_ProbabilityThreshold_get, _pyfreeling.config_options_MACO_ProbabilityThreshold_set)
    PHON_PhoneticsFile = property(_pyfreeling.config_options_PHON_PhoneticsFile_get, _pyfreeling.config_options_PHON_PhoneticsFile_set)
    NEC_NECFile = property(_pyfreeling.config_options_NEC_NECFile_get, _pyfreeling.config_options_NEC_NECFile_set)
    SENSE_ConfigFile = property(_pyfreeling.config_options_SENSE_ConfigFile_get, _pyfreeling.config_options_SENSE_ConfigFile_set)
    UKB_ConfigFile = property(_pyfreeling.config_options_UKB_ConfigFile_get, _pyfreeling.config_options_UKB_ConfigFile_set)
    TAGGER_HMMFile = property(_pyfreeling.config_options_TAGGER_HMMFile_get, _pyfreeling.config_options_TAGGER_HMMFile_set)
    TAGGER_RelaxFile = property(_pyfreeling.config_options_TAGGER_RelaxFile_get, _pyfreeling.config_options_TAGGER_RelaxFile_set)
    TAGGER_RelaxMaxIter = property(_pyfreeling.config_options_TAGGER_RelaxMaxIter_get, _pyfreeling.config_options_TAGGER_RelaxMaxIter_set)
    TAGGER_RelaxScaleFactor = property(_pyfreeling.config_options_TAGGER_RelaxScaleFactor_get, _pyfreeling.config_options_TAGGER_RelaxScaleFactor_set)
    TAGGER_RelaxEpsilon = property(_pyfreeling.config_options_TAGGER_RelaxEpsilon_get, _pyfreeling.config_options_TAGGER_RelaxEpsilon_set)
    TAGGER_Retokenize = property(_pyfreeling.config_options_TAGGER_Retokenize_get, _pyfreeling.config_options_TAGGER_Retokenize_set)
    TAGGER_ForceSelect = property(_pyfreeling.config_options_TAGGER_ForceSelect_get, _pyfreeling.config_options_TAGGER_ForceSelect_set)
    PARSER_GrammarFile = property(_pyfreeling.config_options_PARSER_GrammarFile_get, _pyfreeling.config_options_PARSER_GrammarFile_set)
    DEP_TxalaFile = property(_pyfreeling.config_options_DEP_TxalaFile_get, _pyfreeling.config_options_DEP_TxalaFile_set)
    DEP_TreelerFile = property(_pyfreeling.config_options_DEP_TreelerFile_get, _pyfreeling.config_options_DEP_TreelerFile_set)
    COREF_CorefFile = property(_pyfreeling.config_options_COREF_CorefFile_get, _pyfreeling.config_options_COREF_CorefFile_set)
    SEMGRAPH_SemGraphFile = property(_pyfreeling.config_options_SEMGRAPH_SemGraphFile_get, _pyfreeling.config_options_SEMGRAPH_SemGraphFile_set)

    def __init__(self):
        _pyfreeling.config_options_swiginit(self, _pyfreeling.new_config_options())
    __swig_destroy__ = _pyfreeling.delete_config_options

# Register config_options in _pyfreeling:
_pyfreeling.config_options_swigregister(config_options)

class invoke_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    InputLevel = property(_pyfreeling.invoke_options_InputLevel_get, _pyfreeling.invoke_options_InputLevel_set)
    OutputLevel = property(_pyfreeling.invoke_options_OutputLevel_get, _pyfreeling.invoke_options_OutputLevel_set)
    MACO_UserMap = property(_pyfreeling.invoke_options_MACO_UserMap_get, _pyfreeling.invoke_options_MACO_UserMap_set)
    MACO_AffixAnalysis = property(_pyfreeling.invoke_options_MACO_AffixAnalysis_get, _pyfreeling.invoke_options_MACO_AffixAnalysis_set)
    MACO_MultiwordsDetection = property(_pyfreeling.invoke_options_MACO_MultiwordsDetection_get, _pyfreeling.invoke_options_MACO_MultiwordsDetection_set)
    MACO_NumbersDetection = property(_pyfreeling.invoke_options_MACO_NumbersDetection_get, _pyfreeling.invoke_options_MACO_NumbersDetection_set)
    MACO_PunctuationDetection = property(_pyfreeling.invoke_options_MACO_PunctuationDetection_get, _pyfreeling.invoke_options_MACO_PunctuationDetection_set)
    MACO_DatesDetection = property(_pyfreeling.invoke_options_MACO_DatesDetection_get, _pyfreeling.invoke_options_MACO_DatesDetection_set)
    MACO_QuantitiesDetection = property(_pyfreeling.invoke_options_MACO_QuantitiesDetection_get, _pyfreeling.invoke_options_MACO_QuantitiesDetection_set)
    MACO_DictionarySearch = property(_pyfreeling.invoke_options_MACO_DictionarySearch_get, _pyfreeling.invoke_options_MACO_DictionarySearch_set)
    MACO_ProbabilityAssignment = property(_pyfreeling.invoke_options_MACO_ProbabilityAssignment_get, _pyfreeling.invoke_options_MACO_ProbabilityAssignment_set)
    MACO_CompoundAnalysis = property(_pyfreeling.invoke_options_MACO_CompoundAnalysis_get, _pyfreeling.invoke_options_MACO_CompoundAnalysis_set)
    MACO_NERecognition = property(_pyfreeling.invoke_options_MACO_NERecognition_get, _pyfreeling.invoke_options_MACO_NERecognition_set)
    MACO_RetokContractions = property(_pyfreeling.invoke_options_MACO_RetokContractions_get, _pyfreeling.invoke_options_MACO_RetokContractions_set)
    PHON_Phonetics = property(_pyfreeling.invoke_options_PHON_Phonetics_get, _pyfreeling.invoke_options_PHON_Phonetics_set)
    NEC_NEClassification = property(_pyfreeling.invoke_options_NEC_NEClassification_get, _pyfreeling.invoke_options_NEC_NEClassification_set)
    SENSE_WSD_which = property(_pyfreeling.invoke_options_SENSE_WSD_which_get, _pyfreeling.invoke_options_SENSE_WSD_which_set)
    TAGGER_which = property(_pyfreeling.invoke_options_TAGGER_which_get, _pyfreeling.invoke_options_TAGGER_which_set)
    DEP_which = property(_pyfreeling.invoke_options_DEP_which_get, _pyfreeling.invoke_options_DEP_which_set)

    def __init__(self):
        _pyfreeling.invoke_options_swiginit(self, _pyfreeling.new_invoke_options())
    __swig_destroy__ = _pyfreeling.delete_invoke_options

# Register invoke_options in _pyfreeling:
_pyfreeling.invoke_options_swigregister(invoke_options)

class analyzer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, cfg: "config_options"):
        _pyfreeling.analyzer_swiginit(self, _pyfreeling.new_analyzer(cfg))

    def set_current_invoke_options(self, opt: "invoke_options", check: "bool"=True) -> "void":
        return _pyfreeling.analyzer_set_current_invoke_options(self, opt, check)

    def get_current_invoke_options(self) -> "freeling::analyzer::invoke_options const &":
        return _pyfreeling.analyzer_get_current_invoke_options(self)
    __swig_destroy__ = _pyfreeling.delete_analyzer

    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >":
        return _pyfreeling.analyzer_analyze(self, *args)

    def analyze_as_document(self, text: "std::wstring const &", parag: "bool"=False) -> "freeling::document":
        return _pyfreeling.analyzer_analyze_as_document(self, text, parag)

    def flush_buffer(self, ls: "ListSentence") -> "void":
        return _pyfreeling.analyzer_flush_buffer(self, ls)

    def reset_offset(self) -> "void":
        return _pyfreeling.analyzer_reset_offset(self)

# Register analyzer in _pyfreeling:
_pyfreeling.analyzer_swigregister(analyzer)

class traces(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TraceLevel = property(_pyfreeling.traces_TraceLevel_get, _pyfreeling.traces_TraceLevel_set)
    TraceModule = property(_pyfreeling.traces_TraceModule_get, _pyfreeling.traces_TraceModule_set)

    def __init__(self):
        _pyfreeling.traces_swiginit(self, _pyfreeling.new_traces())
    __swig_destroy__ = _pyfreeling.delete_traces

# Register traces in _pyfreeling:
_pyfreeling.traces_swigregister(traces)

class lang_ident(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.lang_ident_swiginit(self, _pyfreeling.new_lang_ident(*args))
    __swig_destroy__ = _pyfreeling.delete_lang_ident

    def add_language(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.lang_ident_add_language(self, arg2)

    def train_language(self, arg2: "std::wstring const &", arg3: "std::wstring const &", arg4: "std::wstring const &", order: "size_t") -> "void":
        return _pyfreeling.lang_ident_train_language(self, arg2, arg3, arg4, order)

    def identify_language(self, *args) -> "std::wstring":
        return _pyfreeling.lang_ident_identify_language(self, *args)

    def rank_languages(self, *args) -> "std::vector< std::pair< double,std::wstring >,std::allocator< std::pair< double,std::wstring > > >":
        return _pyfreeling.lang_ident_rank_languages(self, *args)

# Register lang_ident in _pyfreeling:
_pyfreeling.lang_ident_swigregister(lang_ident)

class tokenizer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.tokenizer_swiginit(self, _pyfreeling.new_tokenizer(arg2))
    __swig_destroy__ = _pyfreeling.delete_tokenizer

    def tokenize(self, *args) -> "void":
        return _pyfreeling.tokenizer_tokenize(self, *args)

# Register tokenizer in _pyfreeling:
_pyfreeling.tokenizer_swigregister(tokenizer)

class splitter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.splitter_swiginit(self, _pyfreeling.new_splitter(arg2))
    __swig_destroy__ = _pyfreeling.delete_splitter

    def open_session(self) -> "freeling::splitter::session_id":
        return _pyfreeling.splitter_open_session(self)

    def close_session(self, arg2: "freeling::splitter::session_id") -> "void":
        return _pyfreeling.splitter_close_session(self, arg2)

    def split(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >":
        return _pyfreeling.splitter_split(self, *args)

# Register splitter in _pyfreeling:
_pyfreeling.splitter_swigregister(splitter)

class maco_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Lang = property(_pyfreeling.maco_options_Lang_get, _pyfreeling.maco_options_Lang_set)
    LocutionsFile = property(_pyfreeling.maco_options_LocutionsFile_get, _pyfreeling.maco_options_LocutionsFile_set)
    QuantitiesFile = property(_pyfreeling.maco_options_QuantitiesFile_get, _pyfreeling.maco_options_QuantitiesFile_set)
    AffixFile = property(_pyfreeling.maco_options_AffixFile_get, _pyfreeling.maco_options_AffixFile_set)
    CompoundFile = property(_pyfreeling.maco_options_CompoundFile_get, _pyfreeling.maco_options_CompoundFile_set)
    DictionaryFile = property(_pyfreeling.maco_options_DictionaryFile_get, _pyfreeling.maco_options_DictionaryFile_set)
    ProbabilityFile = property(_pyfreeling.maco_options_ProbabilityFile_get, _pyfreeling.maco_options_ProbabilityFile_set)
    NPdataFile = property(_pyfreeling.maco_options_NPdataFile_get, _pyfreeling.maco_options_NPdataFile_set)
    PunctuationFile = property(_pyfreeling.maco_options_PunctuationFile_get, _pyfreeling.maco_options_PunctuationFile_set)
    UserMapFile = property(_pyfreeling.maco_options_UserMapFile_get, _pyfreeling.maco_options_UserMapFile_set)
    Decimal = property(_pyfreeling.maco_options_Decimal_get, _pyfreeling.maco_options_Decimal_set)
    Thousand = property(_pyfreeling.maco_options_Thousand_get, _pyfreeling.maco_options_Thousand_set)
    ProbabilityThreshold = property(_pyfreeling.maco_options_ProbabilityThreshold_get, _pyfreeling.maco_options_ProbabilityThreshold_set)
    InverseDict = property(_pyfreeling.maco_options_InverseDict_get, _pyfreeling.maco_options_InverseDict_set)
    RetokContractions = property(_pyfreeling.maco_options_RetokContractions_get, _pyfreeling.maco_options_RetokContractions_set)

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.maco_options_swiginit(self, _pyfreeling.new_maco_options(arg2))
    __swig_destroy__ = _pyfreeling.delete_maco_options

    def set_data_files(self, usr: "std::wstring const &", pun: "std::wstring const &", dic: "std::wstring const &", aff: "std::wstring const &", comp: "std::wstring const &", loc: "std::wstring const &", nps: "std::wstring const &", qty: "std::wstring const &", prb: "std::wstring const &") -> "void":
        return _pyfreeling.maco_options_set_data_files(self, usr, pun, dic, aff, comp, loc, nps, qty, prb)

    def set_nummerical_points(self, dec: "std::wstring const &", tho: "std::wstring const &") -> "void":
        return _pyfreeling.maco_options_set_nummerical_points(self, dec, tho)

    def set_threshold(self, arg2: "double") -> "void":
        return _pyfreeling.maco_options_set_threshold(self, arg2)

    def set_inverse_dict(self, arg2: "bool") -> "void":
        return _pyfreeling.maco_options_set_inverse_dict(self, arg2)

    def set_retok_contractions(self, arg2: "bool") -> "void":
        return _pyfreeling.maco_options_set_retok_contractions(self, arg2)

# Register maco_options in _pyfreeling:
_pyfreeling.maco_options_swigregister(maco_options)

class maco(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "maco_options"):
        _pyfreeling.maco_swiginit(self, _pyfreeling.new_maco(arg2))
    __swig_destroy__ = _pyfreeling.delete_maco

    def set_active_options(self, umap: "bool", num: "bool", pun: "bool", dat: "bool", dic: "bool", aff: "bool", comp: "bool", rtk: "bool", mw: "bool", ner: "bool", qt: "bool", prb: "bool") -> "void":
        return _pyfreeling.maco_set_active_options(self, umap, num, pun, dat, dic, aff, comp, rtk, mw, ner, qt, prb)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.maco_analyze(self, *args)

# Register maco in _pyfreeling:
_pyfreeling.maco_swigregister(maco)

class RE_map(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.RE_map_swiginit(self, _pyfreeling.new_RE_map(arg2))
    __swig_destroy__ = _pyfreeling.delete_RE_map

    def annotate_word(self, arg2: "word") -> "void":
        return _pyfreeling.RE_map_annotate_word(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.RE_map_analyze(self, *args)

# Register RE_map in _pyfreeling:
_pyfreeling.RE_map_swigregister(RE_map)

class numbers(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &", arg3: "std::wstring const &", arg4: "std::wstring const &"):
        _pyfreeling.numbers_swiginit(self, _pyfreeling.new_numbers(arg2, arg3, arg4))
    __swig_destroy__ = _pyfreeling.delete_numbers

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.numbers_analyze(self, *args)

# Register numbers in _pyfreeling:
_pyfreeling.numbers_swigregister(numbers)

class punts(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.punts_swiginit(self, _pyfreeling.new_punts(arg2))
    __swig_destroy__ = _pyfreeling.delete_punts

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.punts_analyze(self, *args)

# Register punts in _pyfreeling:
_pyfreeling.punts_swigregister(punts)

class dates(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.dates_swiginit(self, _pyfreeling.new_dates(arg2))
    __swig_destroy__ = _pyfreeling.delete_dates

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.dates_analyze(self, *args)

# Register dates in _pyfreeling:
_pyfreeling.dates_swigregister(dates)

class dictionary(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OFF = _pyfreeling.dictionary_OFF
    ON = _pyfreeling.dictionary_ON
    DEFAULT = _pyfreeling.dictionary_DEFAULT

    def __init__(self, Lang: "std::wstring const &", dicFile: "std::wstring const &", sufFile: "std::wstring const &", compFile: "std::wstring const &", invDic: "bool"=False, retok: "bool"=True):
        _pyfreeling.dictionary_swiginit(self, _pyfreeling.new_dictionary(Lang, dicFile, sufFile, compFile, invDic, retok))
    __swig_destroy__ = _pyfreeling.delete_dictionary

    def add_analysis(self, arg2: "std::wstring const &", arg3: "analysis") -> "void":
        return _pyfreeling.dictionary_add_analysis(self, arg2, arg3)

    def remove_entry(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.dictionary_remove_entry(self, arg2)

    def set_retokenize_contractions(self, arg2: "bool") -> "void":
        return _pyfreeling.dictionary_set_retokenize_contractions(self, arg2)

    def set_affix_analysis(self, arg2: "bool") -> "void":
        return _pyfreeling.dictionary_set_affix_analysis(self, arg2)

    def set_compound_analysis(self, arg2: "bool") -> "void":
        return _pyfreeling.dictionary_set_compound_analysis(self, arg2)

    def has_affixes(self) -> "bool":
        return _pyfreeling.dictionary_has_affixes(self)

    def has_compounds(self) -> "bool":
        return _pyfreeling.dictionary_has_compounds(self)

    def search_form(self, arg2: "std::wstring const &", arg3: "ListAnalysis") -> "void":
        return _pyfreeling.dictionary_search_form(self, arg2, arg3)

    def annotate_word(self, *args) -> "void":
        return _pyfreeling.dictionary_annotate_word(self, *args)

    def get_forms(self, arg2: "std::wstring const &", arg3: "std::wstring const &") -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _pyfreeling.dictionary_get_forms(self, arg2, arg3)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.dictionary_analyze(self, *args)

# Register dictionary in _pyfreeling:
_pyfreeling.dictionary_swigregister(dictionary)

class locutions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.locutions_swiginit(self, _pyfreeling.new_locutions(arg2))
    __swig_destroy__ = _pyfreeling.delete_locutions

    def add_locution(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.locutions_add_locution(self, arg2)

    def set_OnlySelected(self, arg2: "bool") -> "void":
        return _pyfreeling.locutions_set_OnlySelected(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.locutions_analyze(self, *args)

# Register locutions in _pyfreeling:
_pyfreeling.locutions_swigregister(locutions)

class ner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.ner_swiginit(self, _pyfreeling.new_ner(arg2))
    __swig_destroy__ = _pyfreeling.delete_ner

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.ner_analyze(self, *args)

# Register ner in _pyfreeling:
_pyfreeling.ner_swigregister(ner)

class quantities(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &", arg3: "std::wstring const &"):
        _pyfreeling.quantities_swiginit(self, _pyfreeling.new_quantities(arg2, arg3))
    __swig_destroy__ = _pyfreeling.delete_quantities

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.quantities_analyze(self, *args)

# Register quantities in _pyfreeling:
_pyfreeling.quantities_swigregister(quantities)

class probabilities(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &", arg3: "double"):
        _pyfreeling.probabilities_swiginit(self, _pyfreeling.new_probabilities(arg2, arg3))
    __swig_destroy__ = _pyfreeling.delete_probabilities

    def annotate_word(self, arg2: "word") -> "void":
        return _pyfreeling.probabilities_annotate_word(self, arg2)

    def set_activate_guesser(self, arg2: "bool") -> "void":
        return _pyfreeling.probabilities_set_activate_guesser(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.probabilities_analyze(self, *args)

# Register probabilities in _pyfreeling:
_pyfreeling.probabilities_swigregister(probabilities)

class hmm_tagger(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &", arg3: "bool", arg4: "unsigned int", kb: "unsigned int"=1):
        _pyfreeling.hmm_tagger_swiginit(self, _pyfreeling.new_hmm_tagger(arg2, arg3, arg4, kb))
    __swig_destroy__ = _pyfreeling.delete_hmm_tagger

    def SequenceProb_log(self, arg2: "sentence", k: "int"=0) -> "double":
        return _pyfreeling.hmm_tagger_SequenceProb_log(self, arg2, k)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.hmm_tagger_analyze(self, *args)

# Register hmm_tagger in _pyfreeling:
_pyfreeling.hmm_tagger_swigregister(hmm_tagger)

class relax_tagger(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &", arg3: "int", arg4: "double", arg5: "double", arg6: "bool", arg7: "unsigned int"):
        _pyfreeling.relax_tagger_swiginit(self, _pyfreeling.new_relax_tagger(arg2, arg3, arg4, arg5, arg6, arg7))
    __swig_destroy__ = _pyfreeling.delete_relax_tagger

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.relax_tagger_analyze(self, *args)

# Register relax_tagger in _pyfreeling:
_pyfreeling.relax_tagger_swigregister(relax_tagger)

class alternatives(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.alternatives_swiginit(self, _pyfreeling.new_alternatives(arg2))
    __swig_destroy__ = _pyfreeling.delete_alternatives

    def get_similar_words(self, arg2: "std::wstring const &", arg3: "ListAlternative") -> "void":
        return _pyfreeling.alternatives_get_similar_words(self, arg2, arg3)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.alternatives_analyze(self, *args)

# Register alternatives in _pyfreeling:
_pyfreeling.alternatives_swigregister(alternatives)

class phonetics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.phonetics_swiginit(self, _pyfreeling.new_phonetics(arg2))
    __swig_destroy__ = _pyfreeling.delete_phonetics

    def get_sound(self, arg2: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.phonetics_get_sound(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.phonetics_analyze(self, *args)

# Register phonetics in _pyfreeling:
_pyfreeling.phonetics_swigregister(phonetics)

class nec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.nec_swiginit(self, _pyfreeling.new_nec(arg2))
    __swig_destroy__ = _pyfreeling.delete_nec

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.nec_analyze(self, *args)

# Register nec in _pyfreeling:
_pyfreeling.nec_swigregister(nec)

class chart_parser(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.chart_parser_swiginit(self, _pyfreeling.new_chart_parser(arg2))
    __swig_destroy__ = _pyfreeling.delete_chart_parser

    def get_start_symbol(self) -> "std::wstring":
        return _pyfreeling.chart_parser_get_start_symbol(self)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.chart_parser_analyze(self, *args)

# Register chart_parser in _pyfreeling:
_pyfreeling.chart_parser_swigregister(chart_parser)

class dep_txala(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &", arg3: "std::wstring const &"):
        _pyfreeling.dep_txala_swiginit(self, _pyfreeling.new_dep_txala(arg2, arg3))
    __swig_destroy__ = _pyfreeling.delete_dep_txala

    def complete_parse_tree(self, *args) -> "void":
        return _pyfreeling.dep_txala_complete_parse_tree(self, *args)

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.dep_txala_analyze(self, *args)

# Register dep_txala in _pyfreeling:
_pyfreeling.dep_txala_swigregister(dep_txala)

class dep_treeler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.dep_treeler_swiginit(self, _pyfreeling.new_dep_treeler(arg2))
    __swig_destroy__ = _pyfreeling.delete_dep_treeler

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.dep_treeler_analyze(self, *args)

# Register dep_treeler in _pyfreeling:
_pyfreeling.dep_treeler_swigregister(dep_treeler)

class senses(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.senses_swiginit(self, _pyfreeling.new_senses(arg2))
    __swig_destroy__ = _pyfreeling.delete_senses

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.senses_analyze(self, *args)

# Register senses in _pyfreeling:
_pyfreeling.senses_swigregister(senses)

class relaxcor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fname: "std::wstring const &"):
        _pyfreeling.relaxcor_swiginit(self, _pyfreeling.new_relaxcor(fname))
    __swig_destroy__ = _pyfreeling.delete_relaxcor

    def set_provide_singletons(self, arg2: "bool") -> "void":
        return _pyfreeling.relaxcor_set_provide_singletons(self, arg2)

    def get_provide_singletons(self) -> "bool":
        return _pyfreeling.relaxcor_get_provide_singletons(self)

    def analyze(self, arg2: "document") -> "void":
        return _pyfreeling.relaxcor_analyze(self, arg2)

# Register relaxcor in _pyfreeling:
_pyfreeling.relaxcor_swigregister(relaxcor)

class semgraph_extract(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, erFile: "std::wstring const &"):
        _pyfreeling.semgraph_extract_swiginit(self, _pyfreeling.new_semgraph_extract(erFile))
    __swig_destroy__ = _pyfreeling.delete_semgraph_extract

    def extract(self, doc: "document") -> "void":
        return _pyfreeling.semgraph_extract_extract(self, doc)

# Register semgraph_extract in _pyfreeling:
_pyfreeling.semgraph_extract_swigregister(semgraph_extract)

class ukb(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.ukb_swiginit(self, _pyfreeling.new_ukb(arg2))
    __swig_destroy__ = _pyfreeling.delete_ukb

    def analyze(self, *args) -> "freeling::document":
        return _pyfreeling.ukb_analyze(self, *args)

# Register ukb in _pyfreeling:
_pyfreeling.ukb_swigregister(ukb)

class sense_info(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sense = property(_pyfreeling.sense_info_sense_get, _pyfreeling.sense_info_sense_set)
    parents = property(_pyfreeling.sense_info_parents_get, _pyfreeling.sense_info_parents_set)
    semfile = property(_pyfreeling.sense_info_semfile_get, _pyfreeling.sense_info_semfile_set)
    words = property(_pyfreeling.sense_info_words_get, _pyfreeling.sense_info_words_set)
    tonto = property(_pyfreeling.sense_info_tonto_get, _pyfreeling.sense_info_tonto_set)
    sumo = property(_pyfreeling.sense_info_sumo_get, _pyfreeling.sense_info_sumo_set)
    cyc = property(_pyfreeling.sense_info_cyc_get, _pyfreeling.sense_info_cyc_set)

    def __init__(self, arg2: "std::wstring const &", arg3: "std::wstring const &"):
        _pyfreeling.sense_info_swiginit(self, _pyfreeling.new_sense_info(arg2, arg3))

    def get_parents_string(self) -> "std::wstring":
        return _pyfreeling.sense_info_get_parents_string(self)
    __swig_destroy__ = _pyfreeling.delete_sense_info

# Register sense_info in _pyfreeling:
_pyfreeling.sense_info_swigregister(sense_info)

class semanticDB(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "std::wstring const &"):
        _pyfreeling.semanticDB_swiginit(self, _pyfreeling.new_semanticDB(arg2))
    __swig_destroy__ = _pyfreeling.delete_semanticDB

    def get_WN_keys(self, arg2: "std::wstring const &", arg3: "std::wstring const &", arg4: "std::wstring const &", arg5: "std::list< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > > &") -> "void":
        return _pyfreeling.semanticDB_get_WN_keys(self, arg2, arg3, arg4, arg5)

    def get_sense_words(self, arg2: "std::wstring const &") -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _pyfreeling.semanticDB_get_sense_words(self, arg2)

    def get_word_senses(self, arg2: "std::wstring const &", arg3: "std::wstring const &", arg4: "std::wstring const &") -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _pyfreeling.semanticDB_get_word_senses(self, arg2, arg3, arg4)

    def get_sense_info(self, arg2: "std::wstring const &") -> "freeling::sense_info":
        return _pyfreeling.semanticDB_get_sense_info(self, arg2)

# Register semanticDB in _pyfreeling:
_pyfreeling.semanticDB_swigregister(semanticDB)

class tagset(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, f: "std::wstring const &"):
        _pyfreeling.tagset_swiginit(self, _pyfreeling.new_tagset(f))
    __swig_destroy__ = _pyfreeling.delete_tagset

    def get_short_tag(self, tag: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.tagset_get_short_tag(self, tag)

    def get_msd_features_map(self, tag: "std::wstring const &") -> "std::map< std::wstring,std::wstring,std::less< std::wstring >,std::allocator< std::pair< std::wstring const,std::wstring > > >":
        return _pyfreeling.tagset_get_msd_features_map(self, tag)

    def get_msd_features(self, tag: "std::wstring const &") -> "std::list< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > >":
        return _pyfreeling.tagset_get_msd_features(self, tag)

    def get_msd_string(self, tag: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.tagset_get_msd_string(self, tag)

    def msd_to_tag(self, *args) -> "std::wstring":
        return _pyfreeling.tagset_msd_to_tag(self, *args)

# Register tagset in _pyfreeling:
_pyfreeling.tagset_swigregister(tagset)

class foma_FSM(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.foma_FSM_swiginit(self, _pyfreeling.new_foma_FSM(*args))
    __swig_destroy__ = _pyfreeling.delete_foma_FSM

    def get_similar_words(self, arg2: "std::wstring const &", arg3: "ListAlternative") -> "void":
        return _pyfreeling.foma_FSM_get_similar_words(self, arg2, arg3)

    def set_cutoff_threshold(self, arg2: "int") -> "void":
        return _pyfreeling.foma_FSM_set_cutoff_threshold(self, arg2)

    def set_num_matches(self, arg2: "int") -> "void":
        return _pyfreeling.foma_FSM_set_num_matches(self, arg2)

    def set_basic_operation_cost(self, arg2: "int") -> "void":
        return _pyfreeling.foma_FSM_set_basic_operation_cost(self, arg2)

    def set_operation_cost(self, arg2: "std::wstring const &", arg3: "std::wstring const &", arg4: "int") -> "void":
        return _pyfreeling.foma_FSM_set_operation_cost(self, arg2, arg3, arg4)

    def get_alphabet(self) -> "std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > >":
        return _pyfreeling.foma_FSM_get_alphabet(self)

# Register foma_FSM in _pyfreeling:
_pyfreeling.foma_FSM_swigregister(foma_FSM)

class fex(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.fex_swiginit(self, _pyfreeling.new_fex(*args))
    __swig_destroy__ = _pyfreeling.delete_fex

    def encode_all(self, arg2: "sentence", arg3: "VectorSetString", arg4: "VectorSetInt") -> "void":
        return _pyfreeling.fex_encode_all(self, arg2, arg3, arg4)

    def encode_name(self, *args) -> "std::vector< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > >,std::allocator< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > > > >":
        return _pyfreeling.fex_encode_name(self, *args)

    def encode_int(self, *args) -> "std::vector< std::set< int,std::less< int >,std::allocator< int > >,std::allocator< std::set< int,std::less< int >,std::allocator< int > > > >":
        return _pyfreeling.fex_encode_int(self, *args)

    def clear_lexicon(self) -> "void":
        return _pyfreeling.fex_clear_lexicon(self)

    def encode_to_lexicon(self, arg2: "sentence") -> "void":
        return _pyfreeling.fex_encode_to_lexicon(self, arg2)

    def save_lexicon(self, arg2: "std::wstring const &", arg3: "double") -> "void":
        return _pyfreeling.fex_save_lexicon(self, arg2, arg3)

# Register fex in _pyfreeling:
_pyfreeling.fex_swigregister(fex)

class fex_lexicon(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.fex_lexicon_swiginit(self, _pyfreeling.new_fex_lexicon(*args))

    def clear_lexicon(self) -> "void":
        return _pyfreeling.fex_lexicon_clear_lexicon(self)

    def add_occurrence(self, arg2: "std::wstring const &") -> "void":
        return _pyfreeling.fex_lexicon_add_occurrence(self, arg2)

    def save_lexicon(self, arg2: "std::wstring const &", arg3: "double") -> "void":
        return _pyfreeling.fex_lexicon_save_lexicon(self, arg2, arg3)

    def get_code(self, arg2: "std::wstring const &") -> "unsigned int":
        return _pyfreeling.fex_lexicon_get_code(self, arg2)

    def get_freq(self, arg2: "std::wstring const &") -> "unsigned int":
        return _pyfreeling.fex_lexicon_get_freq(self, arg2)

    def contains_code(self, arg2: "unsigned int") -> "bool":
        return _pyfreeling.fex_lexicon_contains_code(self, arg2)

    def is_empty(self) -> "bool":
        return _pyfreeling.fex_lexicon_is_empty(self)
    __swig_destroy__ = _pyfreeling.delete_fex_lexicon

# Register fex_lexicon in _pyfreeling:
_pyfreeling.fex_lexicon_swigregister(fex_lexicon)

class util(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def init_locale(arg1: "std::wstring const &") -> "void":
        return _pyfreeling.util_init_locale(arg1)

    @staticmethod
    def wstring2int(arg1: "std::wstring const &") -> "int":
        return _pyfreeling.util_wstring2int(arg1)

    @staticmethod
    def int2wstring(arg1: "int const") -> "std::wstring":
        return _pyfreeling.util_int2wstring(arg1)

    @staticmethod
    def wstring2double(arg1: "std::wstring const &") -> "double":
        return _pyfreeling.util_wstring2double(arg1)

    @staticmethod
    def double2wstring(arg1: "double const") -> "std::wstring":
        return _pyfreeling.util_double2wstring(arg1)

    @staticmethod
    def wstring2longdouble(arg1: "std::wstring const &") -> "long double":
        return _pyfreeling.util_wstring2longdouble(arg1)

    @staticmethod
    def longdouble2wstring(arg1: "long double const") -> "std::wstring":
        return _pyfreeling.util_longdouble2wstring(arg1)

    @staticmethod
    def vector2wstring(arg1: "VectorString", arg2: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.util_vector2wstring(arg1, arg2)

    @staticmethod
    def list2wstring(arg1: "ListString", arg2: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.util_list2wstring(arg1, arg2)

    @staticmethod
    def pairlist2wstring(*args) -> "std::wstring":
        return _pyfreeling.util_pairlist2wstring(*args)

    @staticmethod
    def wstring2list(arg1: "std::wstring const &", arg2: "std::wstring const &") -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _pyfreeling.util_wstring2list(arg1, arg2)

    @staticmethod
    def wstring2vector(arg1: "std::wstring const &", arg2: "std::wstring const &") -> "std::vector< std::wstring,std::allocator< std::wstring > >":
        return _pyfreeling.util_wstring2vector(arg1, arg2)

    @staticmethod
    def capitalization(arg1: "std::wstring const &") -> "int":
        return _pyfreeling.util_capitalization(arg1)

    @staticmethod
    def capitalize(arg1: "std::wstring const &", arg2: "int", arg3: "bool") -> "std::wstring":
        return _pyfreeling.util_capitalize(arg1, arg2, arg3)

    @staticmethod
    def lowercase(arg1: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.util_lowercase(arg1)

    @staticmethod
    def uppercase(arg1: "std::wstring const &") -> "std::wstring":
        return _pyfreeling.util_uppercase(arg1)

    def __init__(self):
        _pyfreeling.util_swiginit(self, _pyfreeling.new_util())
    __swig_destroy__ = _pyfreeling.delete_util

# Register util in _pyfreeling:
_pyfreeling.util_swigregister(util)

def util_init_locale(arg1: "std::wstring const &") -> "void":
    return _pyfreeling.util_init_locale(arg1)

def util_wstring2int(arg1: "std::wstring const &") -> "int":
    return _pyfreeling.util_wstring2int(arg1)

def util_int2wstring(arg1: "int const") -> "std::wstring":
    return _pyfreeling.util_int2wstring(arg1)

def util_wstring2double(arg1: "std::wstring const &") -> "double":
    return _pyfreeling.util_wstring2double(arg1)

def util_double2wstring(arg1: "double const") -> "std::wstring":
    return _pyfreeling.util_double2wstring(arg1)

def util_wstring2longdouble(arg1: "std::wstring const &") -> "long double":
    return _pyfreeling.util_wstring2longdouble(arg1)

def util_longdouble2wstring(arg1: "long double const") -> "std::wstring":
    return _pyfreeling.util_longdouble2wstring(arg1)

def util_vector2wstring(arg1: "VectorString", arg2: "std::wstring const &") -> "std::wstring":
    return _pyfreeling.util_vector2wstring(arg1, arg2)

def util_list2wstring(arg1: "ListString", arg2: "std::wstring const &") -> "std::wstring":
    return _pyfreeling.util_list2wstring(arg1, arg2)

def util_pairlist2wstring(*args) -> "std::wstring":
    return _pyfreeling.util_pairlist2wstring(*args)

def util_wstring2list(arg1: "std::wstring const &", arg2: "std::wstring const &") -> "std::list< std::wstring,std::allocator< std::wstring > >":
    return _pyfreeling.util_wstring2list(arg1, arg2)

def util_wstring2vector(arg1: "std::wstring const &", arg2: "std::wstring const &") -> "std::vector< std::wstring,std::allocator< std::wstring > >":
    return _pyfreeling.util_wstring2vector(arg1, arg2)

def util_capitalization(arg1: "std::wstring const &") -> "int":
    return _pyfreeling.util_capitalization(arg1)

def util_capitalize(arg1: "std::wstring const &", arg2: "int", arg3: "bool") -> "std::wstring":
    return _pyfreeling.util_capitalize(arg1, arg2, arg3)

def util_lowercase(arg1: "std::wstring const &") -> "std::wstring":
    return _pyfreeling.util_lowercase(arg1)

def util_uppercase(arg1: "std::wstring const &") -> "std::wstring":
    return _pyfreeling.util_uppercase(arg1)

class input_conll(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.input_conll_swiginit(self, _pyfreeling.new_input_conll(*args))
    __swig_destroy__ = _pyfreeling.delete_input_conll

    def input_sentences(self, lines: "std::wstring const &", ls: "ListSentence") -> "void":
        return _pyfreeling.input_conll_input_sentences(self, lines, ls)

    def input_document(self, lines: "std::wstring const &", doc: "document") -> "void":
        return _pyfreeling.input_conll_input_document(self, lines, doc)

# Register input_conll in _pyfreeling:
_pyfreeling.input_conll_swigregister(input_conll)

class output_conll(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.output_conll_swiginit(self, _pyfreeling.new_output_conll(*args))
    __swig_destroy__ = _pyfreeling.delete_output_conll

    def PrintHeader(self, sout: "std::wostream &") -> "void":
        return _pyfreeling.output_conll_PrintHeader(self, sout)

    def PrintFooter(self, sout: "std::wostream &") -> "void":
        return _pyfreeling.output_conll_PrintFooter(self, sout)

    def PrintResults(self, *args) -> "std::wstring":
        return _pyfreeling.output_conll_PrintResults(self, *args)

# Register output_conll in _pyfreeling:
_pyfreeling.output_conll_swigregister(output_conll)

class input_freeling(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyfreeling.input_freeling_swiginit(self, _pyfreeling.new_input_freeling())
    __swig_destroy__ = _pyfreeling.delete_input_freeling

    def input_sentences(self, lines: "std::wstring const &", ls: "ListSentence") -> "void":
        return _pyfreeling.input_freeling_input_sentences(self, lines, ls)

# Register input_freeling in _pyfreeling:
_pyfreeling.input_freeling_swigregister(input_freeling)

class output_freeling(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.output_freeling_swiginit(self, _pyfreeling.new_output_freeling(*args))
    __swig_destroy__ = _pyfreeling.delete_output_freeling

    def PrintTree(self, sout: "std::wostream &", n: "TreeConstPreorderIteratorNode", depth: "int") -> "void":
        return _pyfreeling.output_freeling_PrintTree(self, sout, n, depth)

    def PrintDepTree(self, sout: "std::wostream &", n: "TreeConstPreorderIteratorDepnode", depth: "int") -> "void":
        return _pyfreeling.output_freeling_PrintDepTree(self, sout, n, depth)

    def PrintPredArgs(self, sout: "std::wostream &", s: "sentence") -> "void":
        return _pyfreeling.output_freeling_PrintPredArgs(self, sout, s)

    def PrintWord(self, sout: "std::wostream &", w: "word", only_sel: "bool"=True, probs: "bool"=True) -> "void":
        return _pyfreeling.output_freeling_PrintWord(self, sout, w, only_sel, probs)

    def PrintCorefs(self, sout: "std::wostream &", doc: "document") -> "void":
        return _pyfreeling.output_freeling_PrintCorefs(self, sout, doc)

    def PrintSemgraph(self, sout: "std::wostream &", doc: "document") -> "void":
        return _pyfreeling.output_freeling_PrintSemgraph(self, sout, doc)

    def PrintResults(self, *args) -> "std::wstring":
        return _pyfreeling.output_freeling_PrintResults(self, *args)

    def output_senses(self, arg2: "bool") -> "void":
        return _pyfreeling.output_freeling_output_senses(self, arg2)

    def output_all_senses(self, arg2: "bool") -> "void":
        return _pyfreeling.output_freeling_output_all_senses(self, arg2)

    def output_phonetics(self, arg2: "bool") -> "void":
        return _pyfreeling.output_freeling_output_phonetics(self, arg2)

    def output_dep_tree(self, arg2: "bool") -> "void":
        return _pyfreeling.output_freeling_output_dep_tree(self, arg2)

    def output_corefs(self, arg2: "bool") -> "void":
        return _pyfreeling.output_freeling_output_corefs(self, arg2)

    def output_semgraph(self, arg2: "bool") -> "void":
        return _pyfreeling.output_freeling_output_semgraph(self, arg2)

# Register output_freeling in _pyfreeling:
_pyfreeling.output_freeling_swigregister(output_freeling)

class output_json(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.output_json_swiginit(self, _pyfreeling.new_output_json(*args))
    __swig_destroy__ = _pyfreeling.delete_output_json

    def PrintResults(self, *args) -> "std::wstring":
        return _pyfreeling.output_json_PrintResults(self, *args)

# Register output_json in _pyfreeling:
_pyfreeling.output_json_swigregister(output_json)

class output_naf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.output_naf_swiginit(self, _pyfreeling.new_output_naf(*args))
    __swig_destroy__ = _pyfreeling.delete_output_naf

    def PrintResults(self, *args) -> "std::wstring":
        return _pyfreeling.output_naf_PrintResults(self, *args)

    def PrintHeader(self, sout: "std::wostream &") -> "void":
        return _pyfreeling.output_naf_PrintHeader(self, sout)

    def PrintFooter(self, sout: "std::wostream &") -> "void":
        return _pyfreeling.output_naf_PrintFooter(self, sout)

    def ActivateLayer(self, ly: "std::wstring const &", b: "bool") -> "void":
        return _pyfreeling.output_naf_ActivateLayer(self, ly, b)

# Register output_naf in _pyfreeling:
_pyfreeling.output_naf_swigregister(output_naf)

class output_train(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyfreeling.output_train_swiginit(self, _pyfreeling.new_output_train())
    __swig_destroy__ = _pyfreeling.delete_output_train

    def PrintResults(self, *args) -> "std::wstring":
        return _pyfreeling.output_train_PrintResults(self, *args)

# Register output_train in _pyfreeling:
_pyfreeling.output_train_swigregister(output_train)

class output_xml(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyfreeling.output_xml_swiginit(self, _pyfreeling.new_output_xml(*args))
    __swig_destroy__ = _pyfreeling.delete_output_xml

    def PrintHeader(self, sout: "std::wostream &") -> "void":
        return _pyfreeling.output_xml_PrintHeader(self, sout)

    def PrintFooter(self, sout: "std::wostream &") -> "void":
        return _pyfreeling.output_xml_PrintFooter(self, sout)

    def PrintResults(self, *args) -> "std::wstring":
        return _pyfreeling.output_xml_PrintResults(self, *args)

# Register output_xml in _pyfreeling:
_pyfreeling.output_xml_swigregister(output_xml)



